---
layout: post
title: "Push Driven Development with Reactive Extensions"
date: 2011-09-29
comments: false
categories:
 - rx
 - twitter
---

<div class='post'>
<p><br>This is going to be the last post that concludes my series on building a real-time push app with Silverlight.&nbsp; Any additional posts would likely be outside the context of writing a push app and more about how I’m adding features to ping.pong, my Twitter app, so I think this is a good place to wrap up and talk generally from a top down overview of building a push-style application.</p> <p>Here’s a recap of everything discussed so far:</p> <p><a href="http://blingcode.blogspot.com/2011/08/building-real-time-push-app-with.html">Part 1</a>:&nbsp; Basics – Creating an Observable around a basic HTTP web stream against Twitter’s streaming API</p> <p><a href="http://blingcode.blogspot.com/2011/08/building-real-time-push-app-with_27.html">Part 2</a>:&nbsp; Subscription and Observation of Observables</p> <p><a href="http://blingcode.blogspot.com/2011/08/building-real-time-push-app-with_28.html">Part 3</a>:&nbsp; Basics of UX design with a look at shadows and gradients.</p> <p><a href="http://blingcode.blogspot.com/2011/09/building-real-time-push-app-with.html">Part 4</a>:&nbsp; Integrating with 3rd party libraries, notably Caliburn Micro and Linq2Twitter and how to achieve polling with observables.</p> <p><a href="http://blingcode.blogspot.com/2011/09/building-real-time-push-app-with_08.html">Part 5</a>:&nbsp; A minor hick up with Linq2Twitter.</p> <p><a href="http://blingcode.blogspot.com/2011/09/building-real-time-push-app-with_13.html">Part 6</a>:&nbsp; Taking advantage of transparencies to improve the design and reusability of UX.</p> <p><a href="http://blingcode.blogspot.com/2011/09/building-real-time-push-app-with_16.html">Part 7</a>:&nbsp; A summary of all things encountered so far, replacing Linq2Twitter with Hammock, first release of code to <a href="https://github.com/bling/Ping.Pong">GitHub</a>, and a binary released capable pulling and streaming tweets from Twitter.</p> <p><a href="http://blingcode.blogspot.com/2011/09/building-real-time-push-app-with_21.html">Part 8</a>:&nbsp; Examples of using Caliburn Micro to easily resolve data bindings that otherwise would be much more effort.</p> <p>And that leads us to this post…</p> <h3>PDD (Push Driven Development)</h3> <p>One of the main goals of this series is to create a performant Silverlight app based on push principles, as opposed to more traditional pull principles.&nbsp; To that effect, ping.pong has performed remarkably well and is limited only by Twitter’s throttling, which currently appears to be maximum of 50 tweets per second via the streaming API.</p> <p>Writing the application from a push-driven mindset was definitely unintuitive at first, and I had to refactor (actually rewrite is more accurate) the code many times to move closer to a world where the application is simply <em>reacting</em> to events thrown at it (as opposed to asking the world for events).</p> <p>To be absolutely clear on what I mean on the differences between push and pull, here’s a comparison:</p> <table border="0" cellspacing="0" cellpadding="2" width="100%"> <tbody> <tr> <td valign="top"><strong>Pulling</strong></td> <td valign="top"><strong>Push</strong></td></tr> <tr> <td valign="top" width="50%">var e = tweets.GetEnumerator();<br>while (e.MoveNext()) <strong>// is there more?<br></strong>{<br>&nbsp; e.Current; <strong>// get current<br></strong>&nbsp; DoSomething(e.Current);<br>}</td> <td valign="top" width="50%">IObservable&lt;Data&gt; data = /* get source */<br><br><strong>// whenever data comes, do something</strong><br>data.Subscribe(DoSometing); <br></td></tr></tbody></table> <p>On the pulling side, the caller is much more concerned with the logic on how to process each message.&nbsp; It needs to <em>repeatedly</em> ask the world, “hey, is there more data?”.</p> <p>On the push side, the caller merely asks the world, “hey, give me data when you get some”.</p> <p>Twitter is a perfect example because their APIs have both a pulling and pushing models.&nbsp; Traditional clients poll continuously all the time, and many had configurable options to try to stay under the 200 API calls per hour limit.&nbsp; Most of Twitter’s API still consists of pulling, but the user’s home line and searching can be streamed in near real time via the streaming API, aka. push.&nbsp; Streaming tweets effectively removes the API call limit.</p> <h3></h3> <h3>Push and Pull with Reactive Extensions</h3> <p>The beauty of Rx is that regardless of whether it is actually pushing or pulling, the API will look same:</p> <div id="codeSnippetWrapper"> <div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">IObservable&lt;Tweet&gt; tweets = _client.GetHomeTimeline();</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">tweets.Subscribe(t =&gt; { <span style="color: #008000">/* do something with the tweet */</span> });</pre><!--CRLF--></div></div>
<p>As far as the caller is concerned, it doesn’t care (or needs to know) whether the <em>GetHomeTimeline</em> method is polling Twitter or streaming from Twitter.&nbsp; All it needs to know is <em>when</em> a tweet comes it will <em>react</em> and do something in the Subscribe action.</p>
<p>In fact, Subscribe simply means “when you have data, call this”, but that could also be immediately, which would be analogous to IEnumerable.</p>
<p>However, if that was the only thing Rx provided it wouldn’t be as popular as it is, because other pub/sub solutions like the EventAggregator already provide a viable asynchronous solution.</p>
<p>Unlocking Rx’s power comes with its multitude of operators.&nbsp; Here’s an example:</p>
<div id="codeSnippetWrapper">
<div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> IObservable&lt;Tweet&gt; GetStreamingStatuses(<span style="color: #0000ff">this</span> TwitterClient client)</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">{</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">  <span style="color: #0000ff">return</span> client.GetHomeTimeline()</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">      .Merge(client.GetMentions())</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">      .Concat(client.GetStreamingHomeline());</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">}</pre><!--CRLF--></div></div>
<p><em>GetHomeTimeline</em> and <em>GetMentions</em> initiate once-only pull style API calls, while <em>GetStreamingHomeline</em> will initiate a sticky connection and stream subsequent tweets down the pipe.</p>
<p>The <em>Merge</em> operator is defined as this: “Merges an observable sequence of observable sequences into an observable sequence.”</p>
<p>I think a better description would be “whenever there is data from any of the sources, push it through”.&nbsp; In the example above, this would translate to whenever a tweet comes from either the home timeline or the mentions timeline, give me a Tweet (first-come-first-push), followed by anything from the streaming timeline.</p>
<p>And there lies one of the greatest beauties of Rx.&nbsp; <em>All</em> of the complexity lies solely on setting up the stream and operators.&nbsp; And that, also, is its disadvantage.</p>
<h3></h3>
<h3>Rx Complexity</h3>
<p>Let’s take a look at the <em><a href="http://msdn.microsoft.com/en-us/library/hh212146(v=VS.103).aspx">Concat</a></em> operator, defined as: “Concatenates two observable sequences.”&nbsp; In the remarks sections it states this: “The Concat operator runs the first sequence to completion. Then, the second sequence is run to completion effectively concatenating the second sequence to the end of the first sequence.”</p>
<p>Let’s try it out:</p>
<div id="codeSnippetWrapper">
<div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">var a = Observable.Interval(TimeSpan.FromSeconds(1)).Select(x =&gt; x.ToString());</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">var b = Observable.Interval(TimeSpan.FromSeconds(1)).Select(x =&gt; <span style="color: #006080">"s"</span> + x);</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">a.Concat(b).Subscribe(Console.WriteLine);</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">// output: 0, 1, 2, 3, 4...</pre><!--CRLF--></div></div>
<p>As expected, only numbers are printed because the first sequence never ends, so it won’t concatenate the second one.&nbsp; Let’s modify it so that it does finish:</p>
<div id="codeSnippetWrapper">
<div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #0000ff">int</span> count = 0;</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">var a = Observable.Interval(TimeSpan.FromSeconds(1))</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">    .TakeWhile(_ =&gt; ++count &lt; 5)</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">    .Select(x =&gt; x.ToString());</pre><!--CRLF--></div></div>
<p>Note, that using Observable.Generate is preferred because it doesn’t introduce an external variable, but I stuck with Interval so the code looks similar to the second observable.&nbsp; As expected again, it will print “0, 1, 2, s0, s1, s2”.</p>
<p>OK, let’s spice things up.&nbsp; Let’s make <em>b</em> a ConnectableObservable by using the <em><a href="http://msdn.microsoft.com/en-us/library/hh229126(v=VS.103).aspx">Publish</a></em> operator, and immediately call <em>Connect</em>.</p>
<div id="codeSnippetWrapper">
<div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #0000ff">int</span> count = 0;</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">var a = Observable.Interval(TimeSpan.FromSeconds(1))</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">    .TakeWhile(_ =&gt; ++count &lt; 5)</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">    .Select(x =&gt; x.ToString());</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">var b = Observable.Interval(TimeSpan.FromSeconds(1)).Select(_ =&gt; <span style="color: #006080">"s"</span> + _).Publish();</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">b.Connect();</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">a.Concat(b).Subscribe(Console.WriteLine);</pre><!--CRLF--></div></div>
<p>What do you think the output of this will be?&nbsp; The answer is “0, 1, 2, 3, <strong>s5, s6, s7</strong>, …”</p>
<p>Despite using the same <em>Concat</em> operator, the result can be very different depending on the source observables.&nbsp; If you use the <em><a href="http://msdn.microsoft.com/en-us/library/hh229288(v=VS.103).aspx">Replay</a></em> operator, it would have printed “0, 1, 2, 3, s0, s1, s2, …”</p>
<p>Years and years of working in synchronous programming models have trained us to think in synchronous ways, and I picked Concat specifically because Concat also exists in the enumerable world.&nbsp; Observable sequences are asynchronous, so we never know exactly <em>when</em> data comes at us, only what to do when it does.&nbsp; And because streams occur at different times, when you combine them together there are many many ways of doing so (CombineLatest, Merge, Zip, are just a few).</p>
<p>The greatest hurdle to working in Rx is to know what the different combinations do.&nbsp; This takes time and practice.&nbsp; <a href="http://mnajder.blogspot.com/2010/03/rxsandbox-v1.html">RxTools</a> is a great learning tool to test out what all the operators do.</p>
<h3><strong>Unit Testing</strong></h3>
<p>Last but not least, Rx can make it easier to write unit tests.&nbsp; The concept is easy: take some inputs and test the output.&nbsp; In practice this is complicated because applications typically carry a lot of state with them.&nbsp; Even with dependency injection and mocking frameworks I’ve seen a lot of code where for every assert there is 10 lines of mock setup code.</p>
<p>So how does it make it easier to test?&nbsp; It reduces what you need to test to a single method, Subscribe, which takes one input, an IObservable&lt;T&gt;.</p>
<h3>Conclusion</h3>
<p>Rx is a library unlike any other you will use.&nbsp; With other libraries, you will add them to your solution, use a method here or there, and go on with your life.&nbsp; With Rx, it will radically change the way you code and think in general.&nbsp; It’s awesome.</p>  </div>
