<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cqrs on bling on software</title>
    <link>http://bling.github.io/categories/cqrs/</link>
    <description>Recent content in Cqrs on bling on software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 Dec 2010 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://bling.github.io/categories/cqrs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CQRS: Building a “Transactional” Event Store with MongoDB</title>
      <link>http://bling.github.io/blog/2010/12/04/cqrs-building-transactional-event-store/</link>
      <pubDate>Sat, 04 Dec 2010 00:00:00 +0000</pubDate>
      
      <guid>http://bling.github.io/blog/2010/12/04/cqrs-building-transactional-event-store/</guid>
      <description>&lt;div class=&#39;post&#39;&gt;
&lt;p&gt;As you all already know if you’re familiar with MongoDB, is that it does not support transactions.&amp;nbsp; The closest thing we have is atomic modifications of a single document.&lt;/p&gt; &lt;p&gt;The Event Store in a CQRS architecture has the important responsibility of detecting concurrency violations, where two different sources try to update the same version of the aggregate.&amp;nbsp; The one that gets it late should be denied changes into the store with an exception thrown.&amp;nbsp; This ensures the integrity of the data.&lt;/p&gt; &lt;p&gt;Here is a very simple typical implementation of appending events into the event store:&lt;/p&gt;&lt;pre style=&#34;border-bottom: #cecece 1px solid; border-left: #cecece 1px solid; padding-bottom: 5px; background-color: #fbfbfb; min-height: 40px; padding-left: 5px; width: 650px; padding-right: 5px; overflow: auto; border-top: #cecece 1px solid; border-right: #cecece 1px solid; padding-top: 5px&#34;&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;void&lt;/span&gt; Append(Guid id, &lt;span style=&#34;color: #0000ff&#34;&gt;long&lt;/span&gt; expectedVersion, IEnumerable&amp;lt;IEvent&amp;gt; events)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;{
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; &lt;span style=&#34;color: #0000ff&#34;&gt;try&lt;/span&gt;
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; _events.Insert(events.Select(x =&amp;gt; ...)); &lt;span style=&#34;color: #008000&#34;&gt;// convert to storage type&lt;/span&gt;
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; &lt;span style=&#34;color: #0000ff&#34;&gt;catch&lt;/span&gt; (...)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; &lt;span style=&#34;color: #0000ff&#34;&gt;&amp;nbsp; if&lt;/span&gt; (E11000 duplicate key)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; &lt;span style=&#34;color: #0000ff&#34;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; throw&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;new&lt;/span&gt; ConcurrencyException(...);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;}&lt;/pre&gt;&lt;/pre&gt;
&lt;p&gt;Syntax is a mix of C#/pseudo code, but the basic concepts are the same.&amp;nbsp; This assumes that you’ve set up an multi-index on the collection between the ID and the version.&amp;nbsp; Thus, when you insert something that already has a matching ID/version, Mongo will tell you of a duplicate key violation, and all is good.&lt;/p&gt;
&lt;p&gt;But wait!&amp;nbsp; Operations are atomic per document!&amp;nbsp; So what happens if you append 100 events, and it fails on the 43rd one?&amp;nbsp; Events 1 through 42 will continue to exist in the data store, which is bad news.&lt;/p&gt;
&lt;p&gt;Obviously, this solution is not going to work.&amp;nbsp; The next step was to do something like this:&lt;/p&gt;&lt;pre style=&#34;border-bottom: #cecece 1px solid; border-left: #cecece 1px solid; padding-bottom: 5px; background-color: #fbfbfb; min-height: 40px; padding-left: 5px; width: 650px; padding-right: 5px; overflow: auto; border-top: #cecece 1px solid; border-right: #cecece 1px solid; padding-top: 5px&#34;&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;catch&lt;/span&gt; (...)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;{
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;&amp;nbsp; if&lt;/span&gt; (E11000 duplicate keys)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; foreach&lt;/span&gt; (var e &lt;span style=&#34;color: #0000ff&#34;&gt;in&lt;/span&gt; events)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; _events.Delete(&lt;span style=&#34;color: #0000ff&#34;&gt;new&lt;/span&gt; { _id = e._id });
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp;&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; throw&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;new&lt;/span&gt; ConcurrencyException(...);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&amp;nbsp; }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;}&lt;/pre&gt;&lt;/pre&gt;
&lt;p&gt;So, before inserting into the collection, each events gets a generated ObjectID, so that if it fails, the catch exception can simply tell the data store to delete everything.&lt;/p&gt;
&lt;p&gt;At first glance this seems to fix everything, except for one glaring problem.&amp;nbsp; What happens if you lose connection to the database before, or midway sending the deletes?&amp;nbsp; Now you have a problem of &lt;strong&gt;ensuring&lt;/strong&gt; that those deletes are guaranteed, and so then the question that arises from that is &lt;strong&gt;where&lt;/strong&gt; would you store it?&amp;nbsp; A local file?&amp;nbsp; Another database?&amp;nbsp; The problem is, at that moment, if another process in the system queries all events for the same aggregate it will return invalid data.&lt;/p&gt;
&lt;p&gt;So, we’re back to square one.&amp;nbsp; We need to simulate a transaction through a single insert.&lt;/p&gt;
&lt;p&gt;The secret is in the schema design.&amp;nbsp; Initially, we started out with a straight forward row-per-event schema.&amp;nbsp; But since we’re operating with &lt;em&gt;documents&lt;/em&gt;, we can model it as a &lt;em&gt;batch&lt;/em&gt; of events.&lt;/p&gt;
&lt;p&gt;Thus, instead of versioning every event individually, we version a batch of events.&amp;nbsp; For example, originally we would insert 3 events, and the data saved would look like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{ _id = 1, aggregate_id = 1, version = 1, event = { … } }&lt;br&gt;{ _id = 2, aggregate_id = 1, version = 2, event = { … } }&lt;br&gt;{ _id = 3, aggregate_id = 1, version = 3, event = { … } }&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In the new schema, it would look like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{ _id = 1, aggregate_id = 1, version = 1, &lt;strong&gt;events&lt;/strong&gt; = [ { … }, { … }, { … }, { … } ] }&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Now, a downside to this approach is you lose a bit of granularity of stored events, since you are grouping multiple events under a single version.&amp;nbsp; However, I don’t see this as a huge loss since the main reason you want to use event sourcing in the first place is to be able to restore an aggregate to any state in its history, and we still retain that functionality.&lt;/p&gt;
&lt;p&gt;In our case, this is working very well for us.&amp;nbsp; When a command gets handled, it generates a bunch of events that get applied and then saved to MongoDB.&amp;nbsp; I can’t think of any scenario where it’d want to replay to the middle of a half-processed command (but of course it’s possible anyways, just reply half of a batch of events).&amp;nbsp; But that’s just asking for trouble.&amp;nbsp; It’s most likely easier to just the re-process the command.&lt;/p&gt;
&lt;p&gt;Now, you may be asking why go through the trouble of batching events when you can just store one document per aggregate, and then put all events in one document?&amp;nbsp; Yes, that would solve the problem very effectively…until you hit the 4MB per document limit ;-)&lt;/p&gt;  &lt;/div&gt;
&lt;h2&gt;Comments&lt;/h2&gt;
&lt;div class=&#39;comments&#39;&gt;
&lt;div class=&#39;comment&#39;&gt;
&lt;div class=&#39;author&#39;&gt;Bailey Ling&lt;/div&gt;
&lt;div class=&#39;content&#39;&gt;
It wouldn&amp;#39;t be any different from processing a new command.  You will need to load all snapshots/events to get the aggregate root to the latest version.  Events should typically be &amp;quot;fire and forget&amp;quot;.  If you require them to be guaranteed delivery it&amp;#39;s better to restructure them as commands.&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;comment&#39;&gt;
&lt;div class=&#39;author&#39;&gt;bodrin&lt;/div&gt;
&lt;div class=&#39;content&#39;&gt;
Nice, thanks for answering :)&lt;br /&gt;I should definitely take a closer look at the MongoDB! Sounds very interesting :)&lt;br /&gt;&lt;br /&gt;On the other hand I&amp;#39;m still wondering if there is a general approach for this situation - you have done a state transition into the KV/doc DB and you have some events there. Then your system goes down just before it publishes these events on to the wire (some external messaging system). Then when you start again is there an efficient way/query to be done against the KV/doc DB so that you get all the events that haven&amp;#39;t been dispatched yet?&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;comment&#39;&gt;
&lt;div class=&#39;author&#39;&gt;Bailey Ling&lt;/div&gt;
&lt;div class=&#39;content&#39;&gt;
Well, the easiest way is to cheat and use Mongo as your messaging bus ;-)  There&amp;#39;s a bunch of examples on the web.  Basically, you create a direct connection against the database and read the oplog.  This is the mechanism that Mongo uses to do replication, so you get near real-time performance.  Since it&amp;#39;s only one system to manage, rather than two in concert, it&amp;#39;s a bit easier to maintain.  You&amp;#39;ll get the same guarantees as any other write to a Mongo node.&lt;br /&gt;&lt;br /&gt;If you must go to another messaging system it&amp;#39;ll depend on the guarantees of that implementation.  It&amp;#39;s not the end of the world to tell the user to &amp;quot;try again later&amp;quot;, assuming that&amp;#39;s acceptable for the 0.01% of the time.&lt;br /&gt;&lt;br /&gt;Also, if the messaging system is down, you can still read from the event store to get the latest information (and is required for stale nodes joining the system).&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;comment&#39;&gt;
&lt;div class=&#39;author&#39;&gt;bodrin&lt;/div&gt;
&lt;div class=&#39;content&#39;&gt;
Hi, I want to ask how do you dispatch the events. I guess the flow is somthing like this:&lt;br /&gt;&lt;br /&gt;1. receive a command&lt;br /&gt;2. load the related AR and process the command which produces some events - a batch&lt;br /&gt;3. store the event batch in MongoDB, e.g. at &lt;br /&gt;{ &amp;quot;_id&amp;quot;: { &amp;quot;aggregate&amp;quot;: 1234, &amp;quot;version&amp;quot;: 65 } }&lt;br /&gt;4. dispatch the events to some messaging system&lt;br /&gt;5. mark the { &amp;quot;_id&amp;quot;: { &amp;quot;aggregate&amp;quot;: 1234, &amp;quot;version&amp;quot;: 65 } } as dispatched&lt;br /&gt;&lt;br /&gt;So if this is similar to what you are doing I&amp;#39;m wondering what if the system goes down just after step 3. ?&lt;br /&gt;The events are not dispatched, but how do you find that after restart? Is there an efficient way with MongoDb and/or with other documen / KV stores?&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;comment&#39;&gt;
&lt;div class=&#39;author&#39;&gt;bling&lt;/div&gt;
&lt;div class=&#39;content&#39;&gt;
Thanks for the comments!&lt;br /&gt;&lt;br /&gt;You are absolutely right in all of your points.&lt;br /&gt;&lt;br /&gt;Actually, each individual event in my system is meaningless unless it is part of a batch.  The batch is the only thing that is versioned, and the batch version is required to save or get events from the store.&lt;br /&gt;&lt;br /&gt;As for duplicate handling, since I wrote the post I implemented _id as a complex object like this:&lt;br /&gt;&lt;br /&gt;{ &amp;quot;_id&amp;quot;: { &amp;quot;aggregate&amp;quot;: 1234, &amp;quot;version&amp;quot;: 65 } }&lt;br /&gt;&lt;br /&gt;_id is always indexed, and unique.  If version 66 already exists, the 2nd command handler will simply fail, and the event store will continue to have good, consistent data.&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;comment&#39;&gt;
&lt;div class=&#39;author&#39;&gt;Jonathan Oliver&lt;/div&gt;
&lt;div class=&#39;content&#39;&gt;
Awesome post.  &lt;br /&gt;&lt;br /&gt;When I started writing version 2.0 of my EventStore library, I wanted to ensure that NoSQL databases such as MongoDB could be handled.  Pushing everything up as a single batch is critical.&lt;br /&gt;&lt;br /&gt;Here is the implementation for Mongo:&lt;br /&gt;https://github.com/joliver/EventStore/tree/master/src/proj/EventStore.Persistence.MongoPersistence&lt;br /&gt;&lt;br /&gt;Here is the design guide:&lt;br /&gt;http://jonathan-oliver.blogspot.com/2010/12/cqrs-eventstore-v2-architectural.html&lt;br /&gt;&lt;br /&gt;There are three quick things I wanted to mention regarding your implementation.  First, because you&amp;#39;re now pushing things up as a batch, you can no longer use the event version as an optimistic control technique.  Instead, you&amp;#39;ll want to number each batch that you push using a sequential, incrementing value.&lt;br /&gt;&lt;br /&gt;Lastly, if you only push the event information, you may lose some context because there is oftentimes metadata associated with all of the events that you&amp;#39;ll want to store.&lt;br /&gt;&lt;br /&gt;You&amp;#39;ll also want to consider what happens when a message is processed more than once which causes a batch to be written.  NoSQL doesn&amp;#39;t provide any guarantees related to de-duplication so you&amp;#39;ll need to handle that in your application code/event store code.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>CQRS: Auto register event handlers</title>
      <link>http://bling.github.io/blog/2010/11/23/cqrs-auto-register-event-handlers/</link>
      <pubDate>Tue, 23 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>http://bling.github.io/blog/2010/11/23/cqrs-auto-register-event-handlers/</guid>
      <description>&lt;div class=&#39;post&#39;&gt;
&lt;p&gt;I’m not going to go into detail about what the deal is about event handlers in a CQRS architecture, since a quick Google/Bing search will give plenty of very good information.&amp;nbsp; What this post is about is a solution to the “how do I quickly register something to handle a bunch of events” without copying pasting all over the place. There are other solutions out there, like &lt;a href=&#34;http://thinkbeforecoding.com/post/2009/11/03/Event-Sourcing-and-CQRS-Dispatch-options&#34;&gt;this one&lt;/a&gt;.&amp;nbsp; Here’s something I came up with (took some concepts from my post on &lt;a href=&#34;http://blingcode.blogspot.com/2010/10/yet-another-weak-event-for-wpf.html&#34;&gt;Weak Events&lt;/a&gt;).&lt;/p&gt;&lt;pre style=&#34;border-bottom: #cecece 1px solid; border-left: #cecece 1px solid; padding-bottom: 5px; background-color: #fbfbfb; min-height: 40px; padding-left: 5px; width: 650px; padding-right: 5px; overflow: auto; border-top: #cecece 1px solid; border-right: #cecece 1px solid; padding-top: 5px&#34;&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;&lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;class&lt;/span&gt; Aggregate
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;{
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;void&lt;/span&gt; OpenEventHandler&amp;lt;&lt;span style=&#34;color: #0000ff&#34;&gt;in&lt;/span&gt; TTarget, &lt;span style=&#34;color: #0000ff&#34;&gt;in&lt;/span&gt; TEvt&amp;gt;(TTarget target, TEvt @&lt;span style=&#34;color: #0000ff&#34;&gt;event&lt;/span&gt;);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;readonly&lt;/span&gt; IDictionary&amp;lt;Type, OpenEventHandler&amp;lt;Game, IEvent&amp;gt;&amp;gt; _evtHandlers = &lt;span style=&#34;color: #0000ff&#34;&gt;new&lt;/span&gt; Dictionary&amp;lt;Type, OpenEventHandler&amp;lt;Game, IEvent&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;   
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; Aggregate()
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    var methods = from m &lt;span style=&#34;color: #0000ff&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;typeof&lt;/span&gt;(Game).GetMethods(BindingFlags.NonPublic | BindingFlags.Instance)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    let p = m.GetParameters()
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;            where m.Name == &#34;&lt;span style=&#34;color: #8b0000&#34;&gt;ApplyEvent&lt;/span&gt;&#34; &amp;amp;&amp;amp; p.Length == 1 &amp;amp;&amp;amp; &lt;span style=&#34;color: #0000ff&#34;&gt;typeof&lt;/span&gt;(IEvent).IsAssignableFrom(p[0].ParameterType)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;            select m;
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    var registerForwarder = &lt;span style=&#34;color: #0000ff&#34;&gt;typeof&lt;/span&gt;(Game).GetMethod(&#34;&lt;span style=&#34;color: #8b0000&#34;&gt;RegisterForwarder&lt;/span&gt;&#34;, BindingFlags.NonPublic | BindingFlags.Static);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    &lt;span style=&#34;color: #0000ff&#34;&gt;foreach&lt;/span&gt; (var m &lt;span style=&#34;color: #0000ff&#34;&gt;in&lt;/span&gt; methods)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;      Type eventType = m.GetParameters()[0].ParameterType;
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;      var forwarder = registerForwarder.MakeGenericMethod(eventType).Invoke(&lt;span style=&#34;color: #0000ff&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color: #0000ff&#34;&gt;new&lt;/span&gt;[] { m });
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;      _evtHandlers[eventType] = (OpenEventHandler&amp;lt;Game, IEvent&amp;gt;)forwarder;
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;static&lt;/span&gt; OpenEventHandler&amp;lt;Game, IEvent&amp;gt; RegisterForwarder&amp;lt;TEvt&amp;gt;(MethodInfo method)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    var invoker = &lt;span style=&#34;color: #0000ff&#34;&gt;typeof&lt;/span&gt;(OpenEventHandler&amp;lt;,&amp;gt;).MakeGenericType(&lt;span style=&#34;color: #0000ff&#34;&gt;typeof&lt;/span&gt;(Game), &lt;span style=&#34;color: #0000ff&#34;&gt;typeof&lt;/span&gt;(TEvt));
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    var forwarder = (OpenEventHandler&amp;lt;Game, TEvt&amp;gt;)Delegate.CreateDelegate(invoker, &lt;span style=&#34;color: #0000ff&#34;&gt;null&lt;/span&gt;, method);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    &lt;span style=&#34;color: #0000ff&#34;&gt;return&lt;/span&gt; (g, e) =&amp;gt; forwarder(g, (TEvt)e);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt; 
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;void&lt;/span&gt; ApplyEvent(EventHappened e)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    _something = e.Something;
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt; 
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  &lt;span style=&#34;color: #0000ff&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #0000ff&#34;&gt;void&lt;/span&gt; ApplyChanges(IEnumerable&amp;lt;IEvent&amp;gt; events)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    &lt;span style=&#34;color: #0000ff&#34;&gt;foreach&lt;/span&gt; (var e &lt;span style=&#34;color: #0000ff&#34;&gt;in&lt;/span&gt; events)
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    {
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;      _evtHandlers[e.GetType()](&lt;span style=&#34;color: #0000ff&#34;&gt;this&lt;/span&gt;, e);
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;    }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;  }
&lt;/pre&gt;&lt;pre style=&#34;background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,&#39;Courier New&#39;,courier,monospace; font-size: 12px&#34;&gt;}&lt;/pre&gt;&lt;/pre&gt;
&lt;p&gt;A couple things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The registration happens in the &lt;strong&gt;static constructor&lt;/strong&gt;.&amp;nbsp; This is important, because this relatively heavy cost of using reflection only happens once for the aggregate. 
&lt;li&gt;The filtering of methods is arbitrary.&amp;nbsp; I chose “ApplyEvent” here as the convention, but of course you can choose whatever you like. 
&lt;li&gt;&lt;em&gt;ApplyChanges&lt;/em&gt; simply invokes the event handlers dictionary directly.&amp;nbsp; Assuming you’re being a good citizen with the code, accessing &lt;em&gt;_evtHandlers&lt;/em&gt; doesn’t need a lock because once created it should never be modified.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;So in summary, it finds all methods named &lt;em&gt;ApplyEvent&lt;/em&gt; in the current class, and generates an “open delegate” which takes in an extra parameter which is the instance itself.&amp;nbsp; In this case, the instance is the aggregate, as shown in the &lt;em&gt;ApplyChanges&lt;/em&gt; method.&lt;/p&gt;
&lt;p&gt;So there you have it!&amp;nbsp; Excluding the lengthy LINQ query, roughly 10 lines of code to find and register all event handlers in the aggregate.&amp;nbsp; And if you’re wondering, the performance cost is negligible because there’s no reflection involved in the invocation of the handlers.&amp;nbsp; Awesome!&lt;/p&gt;  &lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>