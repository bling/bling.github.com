<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: software tools | bling on software development]]></title>
  <link href="http://bling.github.io//blog/categories/software-tools/atom.xml" rel="self"/>
  <link href="http://bling.github.io//"/>
  <updated>2013-08-20T18:35:42+00:00</updated>
  <id>http://bling.github.io//</id>
  <author>
    <name><![CDATA[Bailey Ling]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Love Affair with Vim]]></title>
    <link href="http://bling.github.io//blog/2013/02/10/love-affair-with-vim/"/>
    <updated>2013-02-10T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2013/02/10/love-affair-with-vim</id>
    <content type="html"><![CDATA[<p>It wasn&rsquo;t too long ago when I was a full-time C# developer and my environment was Visual Studio eight hours a day.  Then, I became a web developer over night cold turkey writing Javascript and CSS.  It&rsquo;s one of the benefits of working for a consulting company.</p>

<p>You might think what does that have to do with the title of this post?  Well, originally my plan was to write a blog post contrasting on the differences between Javascript and C#, as well as the development environments and deployment platforms.  But really, what I really wanted to write about was Vim.</p>

<p>Moving from Visual Studio to Vim was a progression through different editors and environments.  The first thing I used to write Javascript was Webstorm.  Over time I realized that you didn&rsquo;t really need an IDE to write Javascript/CSS.  Then, I used Sublime Text for a little bit.  But ultimately, I settled on Vim, and stayed there.</p>

<p>My stubbornness turned out to be beneficial when I was learning Vim because the first month was absolutely painful.  I remapped all of my arrows keys to do nothing to force myself to use hjkl.  Eventually I got the hang of it, and now I definitely have the muscle memory that makes me much more productive when editing (and reading) text.</p>

<!--more-->


<p>By default Vim is just a text editor.  But I work on a project, so like most lazy people I searched for prepackaged plugins and came across two popular distributions: <a href="https://github.com/spf13/spf13-vim">spf13</a> and <a href="https://github.com/carlhuda/janus">janus</a>.  When I installed them, it was like someone took over Vim and made it change into a completely different beast.  I didn&rsquo;t know how to use it anymore.</p>

<p>I took a step back.  I forgot where I got this advice, but I think anyone using Vim needs to do this: <em>start your own vimrc from scratch</em>.</p>

<p>I took a look at all the settings that spf13 and janus changed.  I copied them to my vimrc <em>one by one</em>, and also <code>:help</code>ing each setting so that I knew exactly what it changed.  I must say, Vim&rsquo;s documentation is some of the best and most comprehensive of any tool I&rsquo;ve worked with.  It was incredibly helpful in my progression.</p>

<p>Then, I did the same thing for plugins.  And the nice thing was that most plugins followed the Vim pattern of having good documentation.  After installing <code>fooplugin</code>, I just <code>:help fooplugin</code> and I got all the information I needed to know about the plugin.</p>

<p>I became obsessed with optimizing my vimrc, and trying out different plugins on a daily basis.  And because I was very adamant with trying one plugin at a time, I got to know them very well.  I knew about how to turn certain settings on and off, how to configure their bindings, and more importantly, how it interacted with all of the other plugins I have already installed.  Over time my vimrc became a full blown distribution in its own right, highly customized to my personal work habits.</p>

<p>However, even though I recommend that anyone interested in taking their Vim skills to the next level should do this discovery that I have done, there are certainly classes of plugins that I deem to be <em>must-have</em> for any Vim user and I wanted to highlight them here.</p>

<h1>Plugin Management</h1>

<p>First things first you will need one plugin to rule them all!  <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> changed the way people install plugins by utilizing git submodules.  This has the pros and cons of git submodules, i.e. they track a specific version of the external git repository, so if external plugins are updated frequently you have to manually update all your submodules.</p>

<p>However, more often than not, you just want the latest version.  <a href="https://github.com/gmarik/vundle">Vundle</a> takes the management one step further and will automatically grab source code from Github for you (as well as automatically updating everything to the latest version).</p>

<p>The last one and least known is <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a>, which is like Vundle on steroids.  It adds a whole ton of new features like allowing you to specify installation steps for compiling something.</p>

<h1>Fuzzy File Searching</h1>

<p>This was the major game changer for me and changed the way I worked.  Naturally, proper Vim technique forces your hands to be on the home row, which makes reaching for the mouse (or even the arrow keys) to be inefficient.  Therefore, the fastest way to open a file is usually to type its name.</p>

<p><a href="https://github.com/wincent/Command-T">CommandT</a> (written in Ruby) is noticeably much faster than <a href="https://github.com/kien/ctrlp.vim">CtrlP</a> (pure VimScript), but CtrlP has a lot more features.  There&rsquo;s also <a href="http://www.vim.org/scripts/script.php?script_id=1984">FuzzyFinder</a>, which I have not tried.</p>

<h1>Autocomplete and Snippets</h1>

<p>There are various contenders here.  Generally, you&rsquo;ll find that people fall into two camps.</p>

<ol>
<li><a href="https://github.com/garbas/vim-snipmate">Snipmate</a>/<a href="https://github.com/SirVer/ultisnips">UltiSnips</a> + <a href="https://github.com/ervandew/supertab">SuperTab</a> + <a href="http://www.vim.org/scripts/script.php?script_id=1879">AutoComplPop</a></li>
<li><a href="https://github.com/Shougo/neocomplcache">neocomplcache</a> + <a href="https://github.com/Shougo/neosnippet">neosnippet</a></li>
</ol>


<p>Snipmate is an older implementation of snippets which is getting replaced with UltiSnips.  Supertab gives you an easy way to trigger omnicompletion with (you guessed it) tab, and AutoComplPop is for automatically showing the popup as you type.</p>

<p>Neocomplcache is a very powerful completion plugin.  It runs a little slower than SuperTab because it does a lot more, but I find the performance acceptable so that&rsquo;s what I&rsquo;m using.  And I choose neosnippet over the others simply because it&rsquo;s by the same author and thus has better integration (e.g. available snippets will appear in the list).</p>

<p>And of course, a good collection of snippets like <a href="https://github.com/honza/vim-snippets">honza</a>&rsquo;s collection.</p>

<p><em>edit</em>: Since I last posted this another autocomplete plugin has taken the Vim world by storm.  It is none other than <a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>.  This is a fantastic plugin which shows a lot of promise.  It does not have as many features as neocomplcache yet, but it is improving every day and has a large community gathering around it.  Things can only get better!</p>

<p><em>edit 2</em>: <a href="https://github.com/Shougo/neocomplete.vim">neocomplete</a> is the next generation version of neocomplcache, and despite being in its infancy is showing great progress and has most (if not all) of the features of neocomplcache.  It requires you to recompile vim with lua support, but has the added benefit that it is way faster than before, and unlike YouCompleteMe (which officially does not support Windows), it works very well on Windows as well.</p>

<h1>And that&rsquo;s it!</h1>

<p>What?!  No file browser?  No buffer manager?  Yes, I have all of those installed as well.  In fact, I have over 50 plugins installed in total.  But in my opinion, they are not <em>killer</em> features.  I can live without them.  But if I didn&rsquo;t have fuzzy searching or completion/snippets, I would feel a little too naked.</p>

<p>Out of the box Vim has some interesting defaults, mainly for backwards compatibility with Vi, but I think it&rsquo;s safe to say that anyone who uses Vim seriously will have a custom vimrc.  If you&rsquo;re just starting out and don&rsquo;t know what to change, <a href="https://github.com/tpope/vim-sensible">sensible</a> is a good set of defaults.</p>

<p>Vim has changed my work habits dramatically.  I think and dream Vim.  I install Vim plugins in my browsers.  And every day, she still teaches me new tricks.  It&rsquo;s quite exhilarating!</p>

<p>If you&rsquo;ve read until this point you might be interested in the full set of plugins that I&rsquo;m using.  If so, head over to my <a href="http://bling.github.com/dotvim/">vim distribution project</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SnoopShell: Evolution]]></title>
    <link href="http://bling.github.io//blog/2012/07/29/snoopshell-evolution/"/>
    <updated>2012-07-29T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2012/07/29/snoopshell-evolution</id>
    <content type="html"><![CDATA[<p>It’s been a while since I last announced <a href="http://blingcode.blogspot.com/2012/07/snoopshell-marriage-of-snoop-wpf-and.html">SnoopShell</a>, where I took some PowerShell and injected that into Snoop.  Well, I didn’t stop there!  I decided to continue working on it and adding more useful features.</p>

<p>Well, a bunch of things have changed.  For one, it’s no longer targeted at .NET 4 and PS v3 anymore (and you’ll soon know why).  Second, there’s a bunch of new features!</p>

<h1>Automatic Profile Loading</h1>

<p>Upon startup, the shell will look for a couple well known locations and automatically dot-source them to load them into the current session.  This works the same as the standard $profile.  The filename needs to be <code>SnoopProfile.ps1</code>, and the search paths are <code>%USERPROFILE%,</code> the <code>WindowsPowerShell</code>, and the <code>Scripts</code> folder deployed with Snoop.exe.</p>

<p>This is incredibly useful since you can write your own custom functions and scripts and have them available to you all the time.  As an added bonus, because of the dynamic nature of PowerShell, you can make modifications to the <code>SnoopProfile.ps1,</code> save, and then invoke a <code>. $profile</code> to reload the profile and update the session with your changes (all without restarting the application).</p>

<p>That’s awesome sauce indeed ;&ndash;)</p>

<h1>PowerShell Provider</h1>

<p>This was more of a for-fun thing at first just to see if I could do it.  Writing a PS provider is not fun at all, since it’s not very well documented and I actually needed some help from ILSpy to figure out how things really worked.  Nonetheless, it’s got some basic functionality that is helpful to navigate around.</p>

<p><a href="http://lh6.ggpht.com/-hpRCncySB3g/UBXOagD2xII/AAAAAAAAALs/qBCKmxV-B0M/s1600-h/image%25255B10%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh6.ggpht.com/-QMqNxt2DmZ8/UBXOa1SVqwI/AAAAAAAAAL0/ULMweSOFso0/image_thumb%25255B8%25255D.png?imgmax=800" width="654" height="399"></a></p>

<p>Yep, the selected grid actually has a path, like how you would navigate the file system.  Let’s see what happens with a <code>cd</code>.</p>

<p><a href="http://lh4.ggpht.com/-R3wQmpiA7dw/UBXObb7FNsI/AAAAAAAAAL8/z3mgZwnFLok/s1600-h/image%25255B15%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/-mdRas9rg4gs/UBXOb4W6z7I/AAAAAAAAAME/pNH-1jzMbGA/image_thumb%25255B11%25255D.png?imgmax=800" width="654" height="399"></a></p>

<p>Cool, you can <code>cd</code> into the child “directory”, and it’ll automatically select the item in the tree view as well.  What if you’re lazy and don’t want to type?</p>

<p><a href="http://lh3.ggpht.com/-QgZ0iBA1AKw/UBXOcPU9uDI/AAAAAAAAAMM/iy9qHsS0zHA/s1600-h/image%25255B20%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh5.ggpht.com/-YV-f5-aPnP0/UBXOcRFGPkI/AAAAAAAAAMU/oo85Qg9fohU/image_thumb%25255B14%25255D.png?imgmax=800" width="654" height="399"></a></p>

<p>Wildcards are supported.  And because the visual tree doesn’t exactly require unique names, I needed to trick it by adding a number after each duplicate item.  So the above matches the third Rectangle child of the Grid.</p>

<h1>Code Injection</h1>

<p>One of the cool things about Javascript is that it’s so darn easy to test.  You make a change, save, reload, and you’ll immediately see if something worked or not.  This feedback loop is so fast it changes how you work and formulate ideas.</p>

<p>In the static world, we don’t really have this luxury, and especially not when you’re working on a large project, which at work, takes just under a minute for a full rebuild.  And this is on a monster machine.  Because of this, we had to employ tricks and workarounds to speed things up, like messing with build configurations and build output paths to minimize duplicate work.  Despite that, it’s still a pain to wait for the application to start and all that jazz.</p>

<p>What if we could do the super fast feedback loop development, in a static world?  Well, now you can!</p>

<p>It starts with a simple function:</p>

<p>``` powershell
function replace-command([string]$msg = &lsquo;hello world&rsquo;) {</p>

<pre><code>$action = { [system.windows.messagebox]::show($msg) }.GetNewClosure()
$cmd = new-object galasoft.mvvmlight.command.relaycommand([system.action]$action)
$selected.target.command = $cmd
</code></pre>

<p>}
```</p>

<p>The above function will replace anything that has a <code>Command</code> property on the target, like a Button or MenuItem, with a MessageBox showing a message.  For the curious, <code>GetNewClosure</code> is needed so that $msg is available within the inner script block.  Unlike C#, closures are not automatic.</p>

<p>Since PowerShell is dynamic, if you need to make a change, simply save the script, reload it with a dot-source, which will overwrite the existing function, and then set the target’s <code>Command</code> property again.  Awesome!</p>

<p>The only annoyance is converting PowerShell code back into C# code once you’re done.</p>

<h1>Evolution</h1>

<p>If you made it this far you didn’t forget about my comment about untargeting .NET 4 and PS v3.  Well, changes have been <a href="https://github.com/cplotts/snoopwpf/commit/16030418b14778029d10e198b288b4efa9bad65c">merged</a> to the main branch!  Soon the masses will be able to experiment with supercharging their applications with PowerShell!</p>

<p>I’ll likely continue working on my <a href="https://github.com/bling/snoopwpf">fork</a> as there’s still more goodies I’d like to add.  Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SnoopShell: The marriage of Snoop WPF and PowerShell]]></title>
    <link href="http://bling.github.io//blog/2012/07/01/snoopshell-marriage-of-snoop-wpf-and/"/>
    <updated>2012-07-01T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2012/07/01/snoopshell-marriage-of-snoop-wpf-and</id>
    <content type="html"><![CDATA[<div class='post'>
<p>I was given the opportunity to review a couple chapters of the excellent book <a href="http://shop.oreilly.com/product/0636920024491.do">PowerShell for Developers</a>, written by my colleague <a href="http://dougfinke.com/blog/">Doug Finke</a>.&nbsp; One of the concepts in the book was embedding a PowerShell console into your application.&nbsp; This idea is ingenious and we added this feature to our client’s software, and so far it has increased our productivity and opened the doors to many possibilities.</p> <p>So what’s so cool about embedding a shell into your application?&nbsp; Well, for starters, one of the immediate advantages is that it gives you the opportunity to test your application at run time.&nbsp; If you are implementing the MVVM pattern then basically anything you can see in the UI is bound to some property in your view model.&nbsp; What if you could expose an instance of your view model to the PowerShell console?&nbsp; Yes, you would be able to interact with it directly, change values, and property change notification will kick in and update the UI.</p> <p>The possibilities start to open up from there.&nbsp; You can start scripting out common tasks – write once, run many times.&nbsp; Or you can write a full fledge test suite as a script, give it to a QA tester, and have them run through it as a special kind of integration testing, one that happens with live, real data.&nbsp; Or how about being able to modify code, <em>at runtime</em>, to try out an implementation without need to recompile or restart the application?&nbsp; Sounds pretty awesome to me!</p> <p>With this, I started thinking why don’t I try and add this to Snoop?&nbsp; It’s a staple tool for any WPF developer, and adding scripting capabilities to Snoop will make it even more useful.</p> <p>So, I sat down for a weekend and took a shot at it.&nbsp; And with that, SnoopShell was born!</p> <p>My fork of Snoop can be found here: <a href="https://github.com/bling/snoopwpf">https://github.com/bling/snoopwpf</a></p> <p>It’s still in super-duper alpha, so features/ideas are still getting formulated, but here’s a glimpse of what it can do now.</p> <p>The $root variable points to the root of the tree.&nbsp; As you can see, Snoop represents this as a ApplicationTreeItem, which has a bunch of properties, the important ones being IsSelected and IsExpanded.</p> <p><a href="http://lh6.ggpht.com/-G1xK0p7454U/T_CIl9YKnlI/AAAAAAAAAJg/z4SEb20go04/s1600-h/image%25255B29%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/-NgT7mhbVSBY/T_CImZIe6NI/AAAAAAAAAJk/fkNeG2UGFH0/image_thumb%25255B17%25255D.png?imgmax=800" width="640" height="381"></a></p> <p>Let’s try interacting with the object by setting the IsExpanded to true.</p> <p><a href="http://lh4.ggpht.com/-uKcevwtnUO4/T_CImnGxyWI/AAAAAAAAAJo/5v1AZnM_SHw/s1600-h/image%25255B28%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh6.ggpht.com/-STnkYWGudRU/T_CInKa1nyI/AAAAAAAAAJs/qk92Zjm3BWU/image_thumb%25255B16%25255D.png?imgmax=800" width="640" height="383"></a></p> <p>So far so good.&nbsp; Now let’s find my username using Ctrl+Shift.&nbsp; The $selected variable is automatically synchronized with the selected item in the tree.</p> <p><a href="http://lh6.ggpht.com/-uUeaZMYbuDc/T_CInhNnmAI/AAAAAAAAAJw/Q--l4hrlEis/s1600-h/image%25255B27%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh6.ggpht.com/-hnDhWbHtn8w/T_CIoIzVSCI/AAAAAAAAAJ0/BiqbUMnfigM/image_thumb%25255B15%25255D.png?imgmax=800" width="640" height="379"></a></p>  <p>Let’s do some black magic and change my name.</p> <p><a href="http://lh6.ggpht.com/-hC4FVTnZDxc/T_CIoTrYfiI/AAAAAAAAAJ4/aQQGFbrxCzM/s1600-h/image%25255B26%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/-RqOCvfsU6cU/T_CIo6zvtcI/AAAAAAAAAJ8/e8XMWPj60BM/image_thumb%25255B14%25255D.png?imgmax=800" width="640" height="382"></a></p> <p>Finally, let’s find every ListBox in the application.&nbsp; <em>Find-Item</em> is used to recursively find everything in the visual tree which is a ListBox.</p> <p><a href="http://lh6.ggpht.com/-nlycDcpP-bk/T_CIpXMcWxI/AAAAAAAAAKA/gIGruuduR9g/s1600-h/image%25255B25%25255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh3.ggpht.com/-oAB7IIj6LLY/T_CIqDPWS6I/AAAAAAAAAKE/aX1DNZnIOVo/image_thumb%25255B13%25255D.png?imgmax=800" width="640" height="367"></a></p> <p>And from here, it’s as simple as grabbing the <em>DataContext</em> of any control to get access to the view model.</p> <p>By the way, this is targeting PowerShell V3, so you will need to have the RC installed.</p> <p>Try it out and let me know what you think!</p>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tools I Use To Do What I Do]]></title>
    <link href="http://bling.github.io//blog/2011/06/23/tools-i-use-to-do-what-i-do/"/>
    <updated>2011-06-23T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/06/23/tools-i-use-to-do-what-i-do</id>
    <content type="html"><![CDATA[<div class='post'>
<p>It’s been a while since I last blogged, but I want to get back into it….I just haven’t thought about what I wanna blog about yet.&nbsp; I’m thinking of doing some sort of multi-part series on a topic but haven’t decided on what yet.&nbsp; Nonetheless, just to get the ball rolling again here’s a quick blog post on some of the tools I use to do my every day job that’s in addition to your typical .NET developer tool chain.</p> <p><strong>General</strong></p> <p><a href="http://www.tcbmi.com/strokeit/">StrokeIt</a>:&nbsp; Funny name aside, on any clean install of Windows this is the <strong>first</strong> thing I install.&nbsp; I load up IE and I download this, followed by Chrome/Firefox.&nbsp; It is a mouse gesture program that affects all of Windows.&nbsp; By holding down the right mouse button, and making gestures you can do common tasks like minimize (drag SW), maximize (drag NE), close (draw a C), and others.&nbsp; It’s much faster than clicking the minimize/maximize buttons.&nbsp; For web browsing, creating and close tabs are drag SE and drag NW respectively.&nbsp; Back is W.&nbsp; Forward is E.&nbsp; Working this way is faster than any keyboard shortcut.</p> <p><a href="http://sourceforge.net/projects/console/">Console2</a>:&nbsp; It’s not a necessity, but it’s nice to be able to use a console with a better looking font.&nbsp; You can easily customize to run another shell, and in my case I have Powershell as the shell.</p> <p><a href="http://virtuawin.sourceforge.net/">VirtuaWin</a>:&nbsp; Ironically I don’t use any virtual desktops, but this app creates a nice middle click on any window that lets you mark it as ‘always on top’.</p> <p><a href="http://www.vim.org/">Vim</a>:&nbsp; It was an awful, painful 2 weeks to learn this thing but I’m sure glad I did.</p> <p><strong>Development/Visual Studio</strong></p> <p><a href="http://www.jetbrains.com/resharper/">Resharper</a>:&nbsp; This one doesn’t need much mentioning as anyone serious about programming in .NET has either heard of it, use it, or use one of its competitors like <a href="http://www.devexpress.com/Products/Visual_Studio_Add-in/Coding_Assistance/">CodeRush</a>.</p> <p><a href="http://visualstudiogallery.msdn.microsoft.com/465a0d53-5133-4edd-a0cd-94484fe3d853">AllMargins</a>:&nbsp; This hidden gem is an awesome extension has brings a bunch of very useful features to the editor.&nbsp; It brings structural highlighting, highlighting matching words under caret, and RockScroll inspired scroll bar, and it does it all with little to no cost in performance.</p> <p><a href="http://visualstudiogallery.msdn.microsoft.com/d0d33361-18e2-46c0-8ff2-4adea1e34fef/">Productivity Power Tools</a>:&nbsp; There’s only 2 that I use here: document tabs, and moving lines.&nbsp; All the rest are either eye candy, negligible enhancements, or just plain too slow to be any use in large solutions (solution navigator I’m looking at you!!).</p> <p><a href="http://visualstudiogallery.msdn.microsoft.com/1a67eee3-fdd1-4745-b290-09d649d07ee0">XAML Intellisense Presenter</a>:&nbsp; This is a must-have for anyone who works with XAML in VS regularly.&nbsp; Resharper 6 may soon make this obsolete, however…</p> <p><a href="http://wiki.sharpdevelop.net/ILSpy.ashx">ILSpy</a>/<a href="http://www.jetbrains.com/decompiler/">dotPeek</a>:&nbsp; Decompilers.&nbsp; ‘nuff said.</p> <p><a href="http://snoopwpf.codeplex.com/">Snoop</a>:&nbsp; Staple tool for WPF developers to inspect the visual/logical tree.&nbsp; There’s also <a href="http://wpfinspector.codeplex.com/">WPF Inspector</a> which has a much nicer UI, but unfortunately doesn’t perform as fast.</p> <p><strong>Profiling</strong></p> <p><a href="http://www.red-gate.com/products/dotnet-development/dotnet-developer-bundle/">ANTS</a>/<a href="http://www.jetbrains.com/profiler/">dotTrace</a>/<a href="http://www.yourkit.com/dotnet/download/">YourKit</a>/etc:&nbsp; I’ve used many performance/memory profilers, and those 3 are the ones I like the most.&nbsp; Unfortunately, they all do things the others don’t, and all these things are very useful, so you still end up needing to use all of them to fix the particular problem you’re working on.</p> <p><a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463009">WinDbg</a>: It isn’t every day I use this, but I’m sure glad to know that such a thing exists and the amount of power it gives me.</p> <p><strong>Scripting</strong></p> <p><a href="http://powergui.org/index.jspa">PowerGUI</a>:&nbsp; Best tool I found for editing PowerShell.&nbsp; The intellisense is great and has all the things you were expect when debugging through scripts.</p> <p><strong>Miscellaneous</strong></p> <p><a href="http://www.baremetalsoft.com/baretail/">BareTail</a>:&nbsp; Amazing program which watches log files in real time and can highlight rows based on a search pattern.</p> <p><a href="http://technet.microsoft.com/en-us/scriptcenter/dd742419">PowerShell</a>/<a href="http://cygwin.org/">Cygwin</a>/<a href="http://www.mingw.org/wiki/MSYS">MSYS</a>:&nbsp; I used to be a Cygwin/MSYS user because back in the day I liked to install a different Linux distribution every week so I learned some basic Bash commands and that carried over to Windows.&nbsp; Since PowerShell now exists, we have a real shell in Windows, so I’ve switched over to learn it, since as a Windows developer it’s more applicable to the kind of work I do.</p> <p>&nbsp;</p> <p>And there’s more but that’s enough for now!</p>  </div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>bling</div>
<div class='content'>
Actually, Cygwin/MSYS used to be in my tool chain, but I&#39;ve made an effort to learn PowerShell by making it my shell.<br /><br />I&#39;m still thrown off sometimes because PowerShell operates on objects, rather than text.  Sometimes this makes it easier, sometimes harder.  Grep comes to mind.<br /><br />Check out BareTail if you want to watch log files in real time.</div>
</div>
<div class='comment'>
<div class='author'>Mike McG</div>
<div class='content'>
Nice post! Gonna check out XAML Intellisense Presenter, All Margins, and PowerGUI.<br /><br />For Always on Top functionality, I&#39;ve relied on PowerMenu. It doesn&#39;t have the middle-click (gotta go through the app menu in the window chrome), but it also lets you Minimize to Tray. StexBar is also pretty neat-o, lets you create your own buttons on the Explorer button bar.<br /><br />Maybe due to my *nix background, I also install Cygwin (including sshd which allows me to use Cygwin through PuTTY rather than cmd.exe), grepWin (regular expression per-directory content search), and Tail for Win32 (to watch log files). (In addition to Tail I install Less for Windows and hook it up to StexBar, then use Shift+F to watch files).</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taking a Quick Look at .NET Decompilers]]></title>
    <link href="http://bling.github.io//blog/2011/05/20/taking-quick-look-at-net-decompilers/"/>
    <updated>2011-05-20T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/05/20/taking-quick-look-at-net-decompilers</id>
    <content type="html"><![CDATA[<p>Decompilers in the .NET space has changed a lot since the announcement from Red Gate that they were going to start charging for Reflector, which was the defacto most important/useful tool in any developer&rsquo;s tool belt.</p>

<p>This blog post will be a quick overview to take a look at all the new contenders that have cropped up in the .NET space to see if any of them can dethrone Reflector as the decompiler of choice.  This is only taking a look at the tools as a stand alone product and excludes any IDE integration.</p>

<p>To start, let&rsquo;s take a look at Reflector.</p>

<h1><a href="http://www.reflector.net/">Red Gate Reflector</a> (7.1.0.143)</h1>

<p>Having been around for years, Reflector is a rock solid product that sets the standard for everything else.  It has a simple straight forward interface and has a large following with many 3rd party addins.  It has a search which lets you find types, and an analyzer which shows you incoming and outgoing calls for any method.  It also has the most options for decompiling, giving choices from C# to VB and even Delphi.</p>

<p>Another useful feature is being able change the framework from .NET to WPF to Silverlight.</p>

<p>As of this version it looks like they added tabs, but it for me it only used one at a time…perhaps a limitation of the trial version.</p>

<h1><a href="http://wiki.sharpdevelop.net/ilspy.ashx">ILSpy</a> (1.0.0.822)</h1>

<p>This open source offering at this point looks the same as Reflector did just before Red Gate took over.  It has all the necessities, including search and analyze.  It can only view one thing at a time, and doesn&rsquo;t have support for addins yet.  However, progress on this project is blazing fast and it&rsquo;s only a matter of time before it reaches feature parity with the rest.</p>

<h1><a href="http://www.telerik.com/products/decompiling.aspx">JustDecompile Beta</a> (2011.1.516.2)</h1>

<p>First impression was, damn, this is a nice pretty WPF app.  Onwards, it has a predefined assembly list of .NET2, 4, and Silverlight, which is nice.  What&rsquo;s nicer is that you can save a predefined list for use later, a feature that&rsquo;s absent from the others.  It has search by type, and search by symbol, however, the search is noticeably slower than everything else I tried.  Also, the actual decompiling is much slower than the rest as well.  Like ILSpy, it can only view one thing at a time.</p>

<p>Decompiling to C# and VB are supported, but no IL yet.</p>

<h1><a href="http://www.jetbrains.com/decompiler/">dotPeek EAP</a> (1.0.0.1219)</h1>

<p>I tried an EAP build and I was blown away.  I may be biased because I&rsquo;m a Resharper user, but having almost all of the keyboard shortcuts I have in my muscle memory work in dotPeek was a welcome surprise.  The keyboard navigation makes dotPeek <em>by far</em> the best tool for navigating.  While the others have searches, they only do so at the type level.  With dotPeek (just like Resharper), you can search by type, current type, and even private members.  Inheritance searching like finding implementations, etc., all of that works.  Simply amazing.  Oh, and it also has full tab support.</p>

<p>It was also fast as well, which was a surprise considering it&rsquo;s searching through the entire framework.  Searching all symbols for <code>m_</code> brought a list up in 2 seconds, and subsequent keystrokes narrowing it down occurred within half a second.</p>

<p>The downside?  No support for decompiling to IL, and lambdas aren&rsquo;t fully supported yet.  I&rsquo;m sure these will be done by the time it&rsquo;s released.</p>

<h1>Conclusion</h1>

<p>I guess the most important thing I should be looking at is the actual decompiler, rather than the bells and whistles. If that&rsquo;s what I looked at, this would be a pretty boring post because only Reflector is able to decompile everything out there.</p>

<p>JustDecompile failed to decompile some of the assemblies I threw it at it.  dotPeek at this stage doesn&rsquo;t have good lambda support (if at all).  ILSpy decompiles very well at this point and I&rsquo;d have to go out of my way to find an example where Reflector does it better than ILSpy.</p>

<p>In conclusion, I love dotPeek just because of the awesomeness that is Resharper keyboard shortcuts.  For everything else, ILSpy does the job.</p>

<p>I&rsquo;m actually pretty thankful that Red Gate decided to charge money for Reflector, because that inspired so much competition and we already have 3 viable replacements, all of which are free &mdash; something that wouldn&rsquo;t have happened if Reflector remained free.</p>
]]></content>
  </entry>
  
</feed>
