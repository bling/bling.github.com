<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | bling on software development]]></title>
  <link href="http://bling.github.io//blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://bling.github.io//"/>
  <updated>2013-07-06T03:02:36+00:00</updated>
  <id>http://bling.github.io//</id>
  <author>
    <name><![CDATA[Bailey Ling]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Push Driven Development with Reactive Extensions]]></title>
    <link href="http://bling.github.io//blog/2011/09/29/push-driven-development-with-reactive/"/>
    <updated>2011-09-29T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/09/29/push-driven-development-with-reactive</id>
    <content type="html"><![CDATA[<p>This is going to be the last post that concludes my series on building a real-time push app with Silverlight.  Any additional posts would likely be outside the context of writing a push app and more about how I’m adding features to ping.pong, my Twitter app, so I think this is a good place to wrap up and talk generally from a top down overview of building a push-style application.</p>

<p>Here’s a recap of everything discussed so far:</p>

<p><a href="/blog/2011/08/26/building-real-time-push-app-with-rx-1">Part 1</a>: Basics – Creating an Observable around a basic HTTP web stream against Twitter’s streaming API</p>

<p><a href="/blog/2011/08/26/building-real-time-push-app-with-rx-2">Part 2</a>: Subscription and Observation of Observables</p>

<p><a href="/blog/2011/08/28/building-real-time-push-app-with-rx-3">Part 3</a>:  Basics of UX design with a look at shadows and gradients.</p>

<p><a href="/blog/2011/09/05/building-real-time-push-app-with-rx-4">Part 4</a>:  Integrating with 3rd party libraries, notably Caliburn Micro and Linq2Twitter and how to achieve polling with observables.</p>

<p><a href="/blog/2011/09/08/building-real-time-push-app-with-rx-5">Part 5</a>:  A minor hick up with Linq2Twitter.</p>

<p><a href="/blog/2011/09/13/building-real-time-push-app-with-rx-6">Part 6</a>:  Taking advantage of transparencies to improve the design and reusability of UX.</p>

<p><a href="/blog/2011/09/16/building-real-time-push-app-with-rx-7">Part 7</a>:  A summary of all things encountered so far, replacing Linq2Twitter with Hammock, first release of code to <a href="https://github.com/bling/Ping.Pong">GitHub</a>, and a binary released capable pulling and streaming tweets from Twitter.</p>

<p><a href="/blog/2011/09/21/building-real-time-push-app-with-rx-8">Part 8</a>:  Examples of using Caliburn Micro to easily resolve data bindings that otherwise would be much more effort.</p>

<p>And that leads us to this post…</p>

<h1>PDD (Push Driven Development)</h1>

<p>One of the main goals of this series is to create a performant Silverlight app based on push principles, as opposed to more traditional pull principles.  To that effect, ping.pong has performed remarkably well and is limited only by Twitter’s throttling, which currently appears to be maximum of 50 tweets per second via the streaming API.</p>

<p>Writing the application from a push-driven mindset was definitely unintuitive at first, and I had to refactor (actually rewrite is more accurate) the code many times to move closer to a world where the application is simply <em>reacting</em> to events thrown at it (as opposed to asking the world for events).</p>

<p>To be absolutely clear on what I mean on the differences between push and pull, here’s a comparison:</p>

<table border="0" cellspacing="0" cellpadding="2" width="100%"> <tbody> <tr> <td valign="top"><strong>Pulling</strong></td> <td valign="top"><strong>Push</strong></td></tr> <tr> <td valign="top" width="50%">var e = tweets.GetEnumerator();<br>while (e.MoveNext()) <strong>// is there more?<br></strong>{<br>  e.Current; <strong>// get current<br></strong>  DoSomething(e.Current);<br>}</td> <td valign="top" width="50%">IObservable&lt;Data&gt; data = /* get source */<br><br><strong>// whenever data comes, do something</strong><br>data.Subscribe(DoSometing); <br></td></tr></tbody></table>


<p></p>

<p>On the pulling side, the caller is much more concerned with the logic on how to process each message.  It needs to <em>repeatedly</em> ask the world, &ldquo;hey, is there more data?&rdquo;.</p>

<p>On the push side, the caller merely asks the world, &ldquo;hey, give me data when you get some&rdquo;.</p>

<p>Twitter is a perfect example because their APIs have both a pulling and pushing models.  Traditional clients poll continuously all the time, and many had configurable options to try to stay under the 200 API calls per hour limit.  Most of Twitter’s API still consists of pulling, but the user’s home line and searching can be streamed in near real time via the streaming API, aka. push.  Streaming tweets effectively removes the API call limit.</p>

<h1>Push and Pull with Reactive Extensions</h1>

<p>The beauty of Rx is that regardless of whether it is actually pushing or pulling, the API will look same:</p>

<p><code>csharp
IObservable&lt;Tweet&gt; tweets = _client.GetHomeTimeline();
tweets.Subscribe(t =&gt; { /* do something with the tweet */ });
</code></p>

<p>As far as the caller is concerned, it doesn’t care (or needs to know) whether the <code>GetHomeTimeline</code> method is polling Twitter or streaming from Twitter.  All it needs to know is <em>when</em> a tweet comes it will <em>react</em> and do something in the Subscribe action.</p>

<p>In fact, Subscribe simply means &ldquo;when you have data, call this&rdquo;, but that could also be immediately, which would be analogous to IEnumerable.</p>

<p>However, if that was the only thing Rx provided it wouldn’t be as popular as it is, because other pub/sub solutions like the EventAggregator already provide a viable asynchronous solution.</p>

<p>Unlocking Rx’s power comes with its multitude of operators.  Here’s an example:</p>

<p>``` csharp
public static IObservable<Tweet> GetStreamingStatuses(this TwitterClient client)
{
  return client.GetHomeTimeline()</p>

<pre><code>  .Merge(client.GetMentions())
  .Concat(client.GetStreamingHomeline());
</code></pre>

<p>}
```</p>

<p><code>GetHomeTimeline</code> and <code>GetMentions</code> initiate once-only pull style API calls, while <code>GetStreamingHomeline</code> will initiate a sticky connection and stream subsequent tweets down the pipe.</p>

<p>The <code>Merge</code> operator is defined as this: &ldquo;Merges an observable sequence of observable sequences into an observable sequence.&rdquo;</p>

<p>I think a better description would be &ldquo;whenever there is data from any of the sources, push it through&rdquo;.  In the example above, this would translate to whenever a tweet comes from either the home timeline or the mentions timeline, give me a Tweet (first-come-first-push), followed by anything from the streaming timeline.</p>

<p>And there lies one of the greatest beauties of Rx.  <em>All</em> of the complexity lies solely on setting up the stream and operators.  And that, also, is its disadvantage.</p>

<h1>Rx Complexity</h1>

<p>Let’s take a look at the <a href="http://msdn.microsoft.com/en-us/library/hh212146(v=VS.103">Concat</a>.aspx) operator, defined as: &ldquo;Concatenates two observable sequences.&rdquo;  In the remarks sections it states this: &ldquo;The Concat operator runs the first sequence to completion. Then, the second sequence is run to completion effectively concatenating the second sequence to the end of the first sequence.&rdquo;</p>

<p>Let’s try it out:</p>

<p><code>csharp
var a = Observable.Interval(TimeSpan.FromSeconds(1)).Select(x =&gt; x.ToString());
var b = Observable.Interval(TimeSpan.FromSeconds(1)).Select(x =&gt; "s" + x);
a.Concat(b).Subscribe(Console.WriteLine);
// output: 0, 1, 2, 3, 4...
</code></p>

<p>As expected, only numbers are printed because the first sequence never ends, so it won’t concatenate the second one.  Let’s modify it so that it does finish:</p>

<p>``` csharp
int count = 0;
var a = Observable.Interval(TimeSpan.FromSeconds(1))</p>

<pre><code>.TakeWhile(_ =&gt; ++count &lt; 5)
.Select(x =&gt; x.ToString());
</code></pre>

<p>```</p>

<p>Note, that using <code>Observable.Generate</code> is preferred because it doesn’t introduce an external variable, but I stuck with Interval so the code looks similar to the second observable.  As expected again, it will print &ldquo;0, 1, 2, s0, s1, s2&rdquo;.</p>

<p>OK, let’s spice things up.  Let’s make <code>b</code> a ConnectableObservable by using the <a href="http://msdn.microsoft.com/en-us/library/hh229126(v=VS.103">Publish</a>.aspx) operator, and immediately call <code>Connect</code>.</p>

<p>``` csharp
int count = 0;
var a = Observable.Interval(TimeSpan.FromSeconds(1))</p>

<pre><code>.TakeWhile(_ =&gt; ++count &lt; 5)
.Select(x =&gt; x.ToString());
</code></pre>

<p>var b = Observable.Interval(TimeSpan.FromSeconds(1)).Select(<em> => &ldquo;s&rdquo; + </em>).Publish();
b.Connect();
a.Concat(b).Subscribe(Console.WriteLine);
```</p>

<p>What do you think the output of this will be?  The answer is &ldquo;0, 1, 2, 3, <em>s5, s6, s7</em>, &hellip;&rdquo;</p>

<p>Despite using the same <code>Concat</code> operator, the result can be very different depending on the source observables.  If you use the <a href="http://msdn.microsoft.com/en-us/library/hh229288(v=VS.103">Replay</a>.aspx) operator, it would have printed &ldquo;0, 1, 2, 3, s0, s1, s2, &hellip;&rdquo;</p>

<p>Years and years of working in synchronous programming models have trained us to think in synchronous ways, and I picked Concat specifically because Concat also exists in the enumerable world.  Observable sequences are asynchronous, so we never know exactly <em>when</em> data comes at us, only what to do when it does.  And because streams occur at different times, when you combine them together there are many many ways of doing so (CombineLatest, Merge, Zip, are just a few).</p>

<p>The greatest hurdle to working in Rx is to know what the different combinations do.  This takes time and practice.  <a href="http://mnajder.blogspot.com/2010/03/rxsandbox-v1.html">RxTools</a> is a great learning tool to test out what all the operators do.</p>

<h1>Unit Testing</h1>

<p>Last but not least, Rx can make it easier to write unit tests.  The concept is easy: take some inputs and test the output.  In practice this is complicated because applications typically carry a lot of state with them.  Even with dependency injection and mocking frameworks I’ve seen a lot of code where for every assert there is 10 lines of mock setup code.</p>

<p>So how does it make it easier to test?  It reduces what you need to test to a single method, Subscribe, which takes one input, an <code>IObservable&lt;T&gt;</code></p>

<h1>Conclusion</h1>

<p>Rx is a library unlike any other you will use.  With other libraries, you will add them to your solution, use a method here or there, and go on with your life.  With Rx, it will radically change the way you code and think in general.  It’s awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Real-time Push App with Silverlight: Part 7]]></title>
    <link href="http://bling.github.io//blog/2011/09/16/building-real-time-push-app-with-rx-7/"/>
    <updated>2011-09-16T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/09/16/building-real-time-push-app-with-rx-7</id>
    <content type="html"><![CDATA[<div class='post'>
<h3></h3> <h3>Infrastructure Refactor</h3> <p>A lot of things changed internally, and I mean….a lot….</p> <p>From an infrastructure standpoint, I decided to remove the dependency on LinqToTwitter, and I replaced it with <a href="https://github.com/danielcrenna/hammock">Hammock</a>.&nbsp; A couple things led me to this decision, one being the Silverlight support wasn’t as good as I’d hoped, and the streaming API implementation was limited.&nbsp; After reading the Twitter documentation I realized that the REST API was super simple and I’d be better off writing a simple interface to it.</p> <p>I heard good things about Hammock, so I decided to give that one a try (I wasn’t going to go as far as reimplementing OAuth).&nbsp; It was pretty easy to set up and in the end I was able to get Twitter working again and with less lines of code compared to the beginning of the refactor.</p> <h3>Goals</h3> <p>I had a couple goals for this project:</p> <ul> <li><strong>Learn:</strong>&nbsp; I was a complete newbie to Reactive Extensions when I started but now I understand it enough to hit the ground running with it.&nbsp; I’m still learning about more conventions available to Caliburn.Micro.  <li><strong>UX:</strong>&nbsp; I wanted to learn a little more about interface design.&nbsp; I wanted to know how little changes to gradients, shadows, colors, etc. could have a radically effect in the end result.  <li><strong>Performance:</strong>&nbsp; It should be fast.&nbsp; It should be able to react to real-time data.&nbsp; And it should do it with low CPU utilization.  <li><strong>Concise:</strong>&nbsp; I am a huge advocate for KISS.&nbsp; I like convention over configuration.&nbsp; I like implementing something in 2 lines of code rather than 20 (assuming it’s not cryptic).&nbsp; As I was writing the app and refactoring, if there was an opportunity to remove a line of code, I did it.&nbsp; The result is that the app currently consists of less than 500 lines of code as of this post (excluding XAML).</li></ul> <h3>Tidbits</h3> <p>What are some interest things I learned?</p> <ul> <li>System.Json is an amazing assembly.&nbsp; All you need to do is invoke JsonValue.Parse on a string and it will create a JsonValue for you, which will be a dictionary of key/value pairs.&nbsp; What’s more, by doing something like “string s = json[“text”]” will do an explicit conversion <strong>and unescape JSON characters</strong>, and <strong>only</strong> via the explicit operator.&nbsp; Calling ToString(), even though converting it to a string, will not unescape.&nbsp; This was completely undocumented and only found when I looked at the source code via Resharper’s external sources feature.  <li>Rx is awesome.&nbsp; When I ran into performance problems of trying to stream tweets from the world that contained the letter ‘a’ all I had to do was add an operator to improve the performance (in this case it was Buffer).&nbsp; It should be noted that it is <em>very important</em> to understand what Rx is doing underneath the hood to realize its benefits.&nbsp; Rx lets you refactor 30 lines of async code into 1 operator, but it’s still doing that 30 lines of code – you just don’t see it.  <li>I really, <em>really</em>, like the conventions available from Caliburn.&nbsp; Some of the features that come out of the box from this very small library saves me from writing a lot of boilerplate code like commands, triggers, and evening bindings (Caliburn will auto bind x:Name to a property).  <li>Twitter’s documentation for <a href="https://dev.twitter.com/docs/streaming-api/user-streams">user streams</a> currently sucks and some trial and error was required to get it working.</li></ul> <p>What is the end result of all this effort?&nbsp; We have a styled Twitter app that can update your status, pull your home/mentions timeline, and most importantly will <strong>stream all subsequent tweets</strong>.&nbsp; There’s no pulling and no limits.&nbsp; You will get a tweet of everyone you follow in real-time as it happens.</p> <p>Moreover, there’s a feature to connect to the Streaming API to search Twitter for <em>anything</em>.&nbsp; To get an idea of what we’re talking about, here’s a full screenshot of it:</p> <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/-tB6iLGL85aE/TnNOi7hdq9I/AAAAAAAAAHE/wGjkyHQzYKs/image%25255B20%25255D.png?imgmax=800" width="578" height="328"></p> <p>You read that right.&nbsp; I’m streaming any tweet in the world that has the words ‘and’, ‘the’, ‘yes’, <strong>or</strong> ‘no’ in them.&nbsp; This is streaming around 400kB/s continuously and CPU utilization is under 25%.&nbsp; The tweets are coming so fast it’s impossible to read them (at a rate of 50 tweets/second), so ideally you’d want to specify realistic search terms.</p> <p>Moreover, the majority of the performance cost is actually downloading all the profile images.&nbsp; If I take took out pictures I could stream any tweet in the world that has the letter ‘e’ in it at under 10% CPU.&nbsp; It looks like Twitter limits the rate of tweets to 50 tweets/second because that was the rate for this one as well.</p> <p>Features are minimalistic.&nbsp; You can update your status, but you can’t DM, you can’t RT, you can’t do any of the normal things.&nbsp; My original goal was not to write another Twitter client, but it’s actually quite fun to do so, so I’ll probably eventually get all features in.</p> <p>And as promised, it’s up on <a href="https://github.com/bling/Ping.Pong">GitHub</a>, and version 0.0.0.1 <strong>alpha</strong> (yes! expect bugs!!) is available in the downloads section.&nbsp; Or, here’s a direct link to the XAP file on my <a href="http://dl.dropbox.com/u/2072014/Ping.Pong/PingPongTestPage.html">Dropbox</a>.&nbsp; Have fun!</p>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Real-time Push App with Silverlight: Part 4]]></title>
    <link href="http://bling.github.io//blog/2011/09/05/building-real-time-push-app-with-rx-4/"/>
    <updated>2011-09-05T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/09/05/building-real-time-push-app-with-rx-4</id>
    <content type="html"><![CDATA[<p>Originally I wanted to avoid bringing in external libraries to keep the app as lean as possible, but then I realized that I would spend too much time reinventing the wheel.  Twitter is deprecating basic authentication in the near future, which makes OAuth no longer optional.  Rather than writing yet another Twitter client (if you’re curious I found a great reference <a href="http://chris.59north.com/post/2009/09/16/SilverTweet-e28093-Building-a-Silverlight-Twitter-client-part-1.aspx">here</a>), I fired up <a href="http://nuget.org/">NuGet</a> and brought in <a href="http://linqtotwitter.codeplex.com/">LinqToTwitter</a>, and while I’m there I brought in <a href="http://code.google.com/p/autofac/">Autofac</a> and <a href="http://caliburnmicro.codeplex.com/">Caliburn.Micro</a> as well.</p>

<p>Naturally, LinqToTwitter will work nicely with Rx because as name implies it uses LINQ heavily.  Caliburn.Micro is a MVVM library which I’ve always wanted an excuse to try because of features like this:</p>

<p><code>xml
&lt;ListBox cal:Message.Attach="[Event Loaded] = [LoadList($dataContext)]" /&gt;
</code></p>

<p>That’s only scratching the surface of what Caliburn can do, so it will be a fresh breath of air to see what else it can do.</p>

<p>By default, Caliburn uses MEF to wire up its bootstrapper.  After adding a couple <code>[Import]</code>s and <code>[Export]</code>s, I knew it wasn’t for me.  It works well for writing plugins, i.e. <em>external</em> dependencies because of its built-in assembly scanning capabilities, but for injecting <em>internal</em> dependencies, other IoC containers do a much better job of that.  I used Castle Windsor in past projects, but for a change I’m going to use Autofac which I haven’t used since v2 came out.</p>

<p>When this was all said and done the View was the only thing that didn’t change.  Everything underneath either changed radically or was deleted altogether (because LinqToTwitter provided it).  I added OAuth support and registered my application with Twitter, and with that was the birth of Ping Pong.</p>

<p>This took much longer than expected.  Silverlight 5 RC just came out and it broke pretty much any container (including MEF) for OOB because of a TypeLoadException.  I haven’t been using too many v5 features, so for the time being I downgraded to v4 to get the project working until RC2 comes out.</p>

<p>Integrating LinqToTwitter was a challenge.  The project site has a lot of good documentation, but most of it was for desktop, not Silverlight, and because of that I banged my head a couple times.  I wish I grabbed the source code earlier because it’s there where you’ll find hundreds of working examples (in code!) to do everything with the library (and in Silverlight).</p>

<p>After all that, PingPong now has 3 columns (home, public, sampling) that <em>dynamically resizes</em> (it’s surprising that <a href="http://metrotwit.com">MetroTwit</a> is the only client that does this&hellip;) to the window size.</p>

<p><img src="http://lh4.ggpht.com/-f1uQ63FwyoI/TmU-fK3WfQI/AAAAAAAAAGc/Y26EvwnXy_4/image_thumb%25255B15%25255D.png?imgmax=800" alt="img" /></p>

<p>Oh, and there’s pictures now!  The streaming time line takes significantly more CPU now that it has to load images, but we’re still sitting at around 5-10% for what is continuously streaming data and loading pictures.  Not too shabby!  (It took a couple tries to get a PG-13 screenshot from the public/streaming time lines&hellip;)</p>

<p>To conclude this post in the series, I’m going to talk about converting an asynchronous operation into an Observable that does not follow any predefined pattern.</p>

<h1>Creating an Observable</h1>

<p>One of Silverlight’s limitations is that almost everything needs to be an asynchronous call.  In regards to LinqToTwitter, something like this will fail (but work on desktop):</p>

<p>``` csharp
var tweets = (from t in context.Status</p>

<pre><code>          where t.Type == StatusType.Public
          select t).ToArray();
</code></pre>

<p>```</p>

<p>On Silverlight you will get a single empty element.  To get it working, there is an extension method that comes with the library, and you use it like this:</p>

<p><code>csharp
(from t in context.Status
 where t.Type == StatusType.Public
  select t)
  .AsyncCallback(tweets =&gt; { /* do something with it */ })
  .FirstOrDefault();
</code></p>

<p>Code is self-explanatory.  The <code>FirstOrDefault()</code> exists only to initiate the expression, otherwise it wouldn’t do anything.  So now the question is how do we convert that into an Rx Observable?</p>

<p>Every time I write an Rx query I try to use the least amount of state as possible.  This helps to keep the number unexpected anomalies to a minimum.  In the following section of code, I was able to get it down to 2 fields: <code>_sinceId</code>, and <code>Context</code>.  There is probably some operator that will let me save the sinceId variable from one observable to the next but I wasn’t able to figure it out.  In any case, I came up with this:</p>

<p>``` csharp
_subscription =</p>

<pre><code>Observable.Create&lt;Tweet&gt;(
    ob =&gt; Observable.Interval(TimeSpan.FromSeconds(60))
        .StartWith(-1)
        .SubscribeOnThreadPool()
        .Subscribe(_ =&gt;
        {
            ulong sinceId;
            (ulong.TryParse(_sinceId, out sinceId)
                ? Context.Status.Where(s =&gt; s.Type == statusType &amp;&amp; s.Count == 200)
                : Context.Status.Where(s =&gt; s.Type == statusType &amp;&amp; s.Count == 200 &amp;&amp; s.SinceID == sinceId))
            .AsyncCallback(statuses =&gt;
            {
                foreach (var status in statuses)
                {
                    ob.OnNext(new Tweet(status));
                    _sinceId = status.StatusID;
                }
            })
            .FirstOrDefault(); // materalize the results
        }))
.DispatcherSubscribe(SubscribeToTweet);
</code></pre>

<p>```</p>

<p>That contains some custom code:</p>

<ul>
<li>Context:  is a TwitterContext from LinqToTwitter</li>
<li>DispatcherSubscribe:  is a helper extension method which Subscribes on the ThreadPool, Observes on the Dispatcher, and then Subscribes with the specified action</li>
<li>SubscribeToTweet: a method in the base class which adds to a ObservableCollection so the UI gets updated</li>
</ul>


<p>To translate the code, here is a basic flow of what’s happening:</p>

<ol>
<li>Observable.Create wraps the subscription of another Observable.  It provides access to an IObserver <code>ob</code> which lets you explicitly invoke OnNext().</li>
<li>Observable.Interval will raise an observable every 60 seconds.</li>
<li>The subscription of Observable.Interval will query the TwitterContext for the next set of tweets.</li>
<li>Inside the AsyncCallback, it invokes <code>ob.OnNext</code>as well as keeps track of the ID so the next time it queries it only gets newer tweets.</li>
<li>Finally, <code>DispatcherSubscribe</code> will take the <code>Tweet</code> object and add it to an <code>ObservableCollection&lt;Tweet&gt;</code>, which notifies the UI.</li>
</ol>


<p>As always, you should “clean up your garbage”.  In this respect I was pretty impressed with Rx as it was able to clean up the entire chain of observables with a single call to <code>_subscription.Dispose()</code>.  Nice!</p>

<p>In the next post I’m going to switch back to UI and completely restyle the application.  The code will hit GitHub soon as well (I promise!).  Stay tuned&hellip;</p>

<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>bling</div>
<div class='content'>
Looks like the same StartWith() trick is needed for Observable.Generate.<br /><br />I played around with Observable.Generate and all the expressions I came up looked pretty complicated in comparison with what I originally had.  This is mainly because I need to call OnNext() inside the AsyncCallback, so all solutions either had external Subjects or obscure ways of passing an IObserver around...<br /><br />Maybe I&#39;m overcomplicating things so if you can come up with an example it&#39;d be greatly appreciated.  I&#39;m still a Rx newbie...<br /><br />Thanks!</div>
</div>
<div class='comment'>
<div class='author'>bling</div>
<div class='content'>
Thanks!  I didn&#39;t know about that overload.<br /><br />Is there a way to make it start immediately, like the StartWith(-1) in the original expression?<br /><br />Observable.Generate(<br />   0, <br />   _ =&gt; true,<br />   _ =&gt; _,<br />   _ =&gt;<br />   {<br />     // this doesn&#39;t get called until 60 seconds passes first...<br />     return 0;<br />   }, <br />   _ =&gt; TimeSpan.FromSeconds(60));</div>
</div>
<div class='comment'>
<div class='author'>jwooley</div>
<div class='content'>
Rather than the custom Observable generator with Iterval, why not use Observable.Generate passing in a timespan of 60 seconds?</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Real-time Push App with Silverlight: Part 3]]></title>
    <link href="http://bling.github.io//blog/2011/08/28/building-real-time-push-app-with-rx-3/"/>
    <updated>2011-08-28T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/08/28/building-real-time-push-app-with-rx-3</id>
    <content type="html"><![CDATA[<p>In this part we’re going to fire up Expression Blend (the trial for version 5 can be found <a href="http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;amp;id=9503">here</a>) and do some UI work.</p>

<p>In part 2, I created a simple Twitter client which connected to the streaming API, and connected to the sampling request which brings back random tweets.  Here is the data template:</p>

<p>``` xml
<DataTemplate x:Key="TweetDataTemplate"></p>

<pre><code>&lt;Grid DataContext="{Binding}"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition /&gt;
        &lt;RowDefinition Height="Auto" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;TextBlock FontFamily="{StaticResource FontFamily}" FontSize="12" Text="{Binding Text}" TextWrapping="Wrap" /&gt;
    &lt;TextBlock Grid.Row="1"
               HorizontalAlignment="Right"
               VerticalAlignment="Bottom"
               FontFamily="{StaticResource FontFamily}"
               FontSize="13.333"
               Foreground="BlueViolet"
               Text="{Binding ScreenName}" /&gt;
    &lt;TextBlock Grid.Row="1"
               HorizontalAlignment="Left"
               VerticalAlignment="Bottom"
               FontFamily="{StaticResource FontFamily}"
               FontSize="9.333"
               Foreground="DarkCyan"
               Text="{Binding CreatedAt}" /&gt;
&lt;/Grid&gt;
</code></pre>

<p></DataTemplate>
```
This renders into something like this:</p>

<p><img src="http://lh4.ggpht.com/-ul4umD_jKFs/Tlq_U7HuoLI/AAAAAAAAAFg/pOhMiaqmxcE/s1600/image%25255B4%25255D.png" alt="img" /></p>

<p>The text is randomly generated from Blend’s <a href="http://lmgtfy.com/?q=blend+sample+data">sample</a> capability, which is totally awesome as it allows designers to see what they’re working with, and keeps the sample data separate from the real data.</p>

<p>While design is a matter of personal taste, and you’re bound to get disagreements between different people, if you follow some basic rules you’ll satisfy a greater audience.</p>

<ul>
<li>Subtle gradients and small shadows

<ul>
<li>If you take a look at all the nice interfaces, they tend to use very slight gradients and small shadows.  Most of the time you don’t even notice unless you look closely.</li>
<li>I think Microsoft’s Metro design is beautiful.  Reason?  It emphasizes text over decorations (like gradients and shadows).  This tends to lead to very clean design because there’s very little opportunity to abuse gradients and shadows.</li>
</ul>
</li>
<li>Realism and light sources

<ul>
<li>Continuing on with gradients and shadows, they should be realistic.  Look at your design from a 3D point of view.  Apply a light source from a certain angle, and then apply your shadows relative to that light source.</li>
<li>Convey distance properly

<ul>
<li>Darker shadows imply being closer to the background, whereas lighter shadows imply being further away.  Use blurring to add emphasis to the distance.  <img src="http://lh5.ggpht.com/-YvKRal5ToEw/Tlr6OrRIS4I/AAAAAAAAAFs/AAg79v6y2Cc/image_thumb%25255B14%25255D.png?imgmax=800" alt="eg" /></li>
<li>If you overlap planes you should apply these rules to each individual plane.  Don’t use the same border for everything.  Think about how it would look like in real life if you laid it out like that with pieces of paper.  The shadow sizes for that will be different, so you should do the same.</li>
<li>Also keep in mind that the shadows used above are <em>way</em> too much for any application.  Be subtle!</li>
</ul>
</li>
</ul>
</li>
<li>Consistent theme

<ul>
<li>This one seems obvious but nothing is worse than having a nice looking application bring up an unskinned dialog.</li>
</ul>
</li>
<li>Usability

<ul>
<li>If the design doesn’t serve a purpose to make it more usable, it shouldn’t be there.  Even something as simple as black on white follows this – you do that so you can read text.  However, even something as simple as that can be improved.  Take a look at why the Kindle is so successful.  The readability is better because of the lower contrast between the black and light-brown background.</li>
</ul>
</li>
</ul>


<p>With these starting points, let’s redesign the data template.</p>

<p>``` xml
<DataTemplate x:Key="TweetDataTemplate">
   <Grid></p>

<pre><code>   &lt;Grid.Background&gt;
       &lt;LinearGradientBrush StartPoint="0.5,0" EndPoint="0.5,1"&gt;
           &lt;GradientStop Color="#FFDADADA" /&gt;
           &lt;GradientStop Offset="1" Color="#FFC8C8C8" /&gt;
       &lt;/LinearGradientBrush&gt;
   &lt;/Grid.Background&gt;
   &lt;Grid.RowDefinitions&gt;
       &lt;RowDefinition /&gt;
       &lt;RowDefinition Height="Auto" /&gt;
   &lt;/Grid.RowDefinitions&gt;
   &lt;TextBlock FontFamily="{StaticResource FontFamily}" FontSize="12" Text="{Binding Text}" TextWrapping="Wrap" /&gt;
   &lt;TextBlock Grid.Row="1"
              HorizontalAlignment="Right"
              VerticalAlignment="Bottom"
              FontFamily="{StaticResource FontFamily}"
              FontSize="13.333"
              Foreground="BlueViolet"
              Text="{Binding ScreenName}" /&gt;
   &lt;TextBlock Grid.Row="1"
              HorizontalAlignment="Left"
              VerticalAlignment="Bottom"
              FontFamily="{StaticResource FontFamily}"
              FontSize="9.333"
              Foreground="#FF003D8F"
              Text="{Binding CreatedAt}" /&gt;
   &lt;Border Grid.RowSpan="2" BorderBrush="#FF999999" BorderThickness="0,0,0,1" /&gt;
   &lt;Border Grid.RowSpan="2" BorderBrush="White" BorderThickness="0,1,0,0" /&gt;
</code></pre>

<p>   </Grid>
</DataTemplate>
```</p>

<p>After these changes, it looks like this:</p>

<p><img src="http://lh5.ggpht.com/-fTL8wgr5ebs/Tlr6PGkqyeI/AAAAAAAAAF0/O98iakwvqGc/image_thumb%25255B17%25255D.png?imgmax=800" alt="eg" /></p>

<p>Did you notice the gradient?  You might think after seeing it here to adjust the gradients more so you can see it.  That would be a mistake.  See below.</p>

<p><img src="http://lh6.ggpht.com/--uPF_IEo6LM/Tlr6PpL9YDI/AAAAAAAAAF8/UxqCqYW3Wl4/image_thumb%25255B47%25255D.png?imgmax=800" alt="eg" /></p>

<p>The above is the exact same thing, but stacked vertically three times.  When this happens the subtle difference between the top and bottom of the control is more pronounced, so it looks like multiple panels are aligned together.</p>

<p>However, there’s still a little touch you can add.  The white and gray borders are only 1 pixel high, but that’s the little touch needed to make it look crisp.</p>

<p><img src="http://lh3.ggpht.com/-QHLW-sKfPfI/Tlr6P_c9qLI/AAAAAAAAAGE/kJ0Z8VgS3xg/image_thumb%25255B44%25255D.png?imgmax=800" alt="eg" /></p>

<p>Finally, let’s see the before and after (or eh&hellip;rather after and before, because I took the screenshot backwards :P):</p>

<p><img src="http://lh6.ggpht.com/-tzZ8AVtNv0M/Tlr6QmHJHnI/AAAAAAAAAGM/H1SYEqT6cis/image_thumb%25255B50%25255D.png?imgmax=800" alt="eg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Real-time Push App with Silverlight: Part 2]]></title>
    <link href="http://bling.github.io//blog/2011/08/27/building-real-time-push-app-with-rx-2/"/>
    <updated>2011-08-27T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2011/08/27/building-real-time-push-app-with-rx-2</id>
    <content type="html"><![CDATA[<p>Let’s review the main Rx code from last time:</p>

<p>``` csharp
public IObservable<string> GetJsonStreams()
{</p>

<pre><code>var request = GetRequest();
return Observable.FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse)()
    .Select(wr =&gt; wr.GetResponseStream())
    .Select(str =&gt; Observable.FromAsyncPattern&lt;byte[], int, int, int&gt;(str.BeginRead, str.EndRead))
    .SelectMany(ParseJson);
</code></pre>

<p>}
```
One thing I didn’t like about this was that the web request object was created regardless of whether the Observable gets a subscription or not.  This is potentially wasted resources, and I wanted to refactor this to be completely lazy.</p>

<p>And with this I started to run into my first &ldquo;huh?&rdquo; moments with Rx: I blocked the UI thread.  How did I do that? I started down the path of exploring some more of the Rx methods, which lead me to <code>Create</code>, which lets you manually call <code>OnNext</code>.  With this train of thought, I came up with something like this:
``` csharp
return Observable.Create<string>(obs =></p>

<pre><code>{
    var request = GetRequest();
    var response = Observable.FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse)().First();
    var str = response.GetResponseStream();
    var reader = Observable.FromAsyncPattern&lt;byte[], int, int, int&gt;(str.BeginRead, str.EndRead);
    foreach (var json in ParseJson(reader))
    obs.OnNext(json);

    obs.OnCompleted();
    return str;
});
</code></pre>

<p><code>``
Great! The initialization of the web request only occurs when subscribed! And it will even dispose the stream (by returning</code>str`) upon unsubscription.  I ran the app and the UI thread immediately blocked.  What happened?</p>

<p>Rx has the concept of subscription and observation, and provides a way to subscribe and observe on different threads.  Here is the original code that subscribed:</p>

<p><code>csharp
s.GetJsonStreams()
   .ObserveOnDispatcher()
   .Subscribe(x =&gt; Text = x);
</code>
Can you spot the error? I explicitly told Rx to observe on the dispatcher thread, because I want the action inside <code>Subscribe</code> to be invoked on the UI thread, but I didn’t specify where I want to set up the subscription.  Since I left it out, it uses the current thread, which happens to be the UI thread.  To solve this, it’s as simple as doing this:</p>

<p>``` csharp
s.GetJsonStreams()</p>

<pre><code>.SubscribeOn(Scheduler.ThreadPool)
.ObserveOnDispatcher()
.Subscribe(x =&gt; Text = x);
</code></pre>

<p><code>``
That’s it! Easy! This also follows one of the most important guidelines when using Rx: *Subscription and Observation should be done as late as possible*, typically just before the</code>Subscribe`.  Anything more and you’ll likely make Rx spawn more threads than are necessary or some other nasty bugs.  <a href="http://en.wikipedia.org/wiki/KISS_principle">KISS</a>!</p>

<p>Now with that out of the way, let’s replace the boring TextBlock with something more usable.  First, I need to parse all the JSON streams I’m getting into bindable models.  To do that, I upgraded my StreamReader component and threw in System.Json for some basic parsing:</p>

<p>``` csharp
public class TweetParser
{</p>

<pre><code>private int _stack;
private readonly StringBuilder _sb = new StringBuilder();

public IEnumerable&lt;Tweet&gt; Parse(byte[] buffer, int count)
{
    for (int i = 0; i &lt; count; i++)
    {
        var current = (char)buffer[i];
        _sb.Append(current);

        if (current == '{') _stack++;
        else if (current == '}') _stack--;

        if (_stack == 0 &amp;_sb.Length &gt; 0)
        {
            Tweet tweet;
            var value = JsonValue.Parse(_sb.ToString());

            if (value is JsonObject &amp;Tweet.TryParse((JsonObject)value, out tweet))
                yield return tweet;

            _sb.Clear();
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Nothing overly complicated.  Next, the Tweet object:</p>

<p>``` csharp
public class Tweet
{</p>

<pre><code>private readonly JsonObject _json;

public static bool TryParse(JsonObject value, out Tweet tweet)
{
    if (value.ContainsKey("text") &amp;value.ContainsKey("user"))
    {
        tweet = new Tweet(value);
        return true;
    }
    tweet = null;
    return false;
}

private Tweet(JsonObject json)
{
    _json = json;
}

public string Text
{
    get { return _json["text"].ToValueString(); }
}

public string ScreenName
{
    get { return _json["user"]["screen_name"].ToValueString(); }
}
</code></pre>

<p>}</p>

<p>internal static class TweetEx
{</p>

<pre><code>public static string ToValueString(this JsonValue s)
{
    return s.ToString().Trim('"');
}
</code></pre>

<p>}
<code>``
To keep things simple I’m only extracting the screen name and text.  I won’t bore you setting up the views since it’s just simple ListBox bound to an</code>ObservableCollection<Tweet>`, and a DataTemplate for Tweet.  When it’s all said and done, we see something like this:</p>

<p><img src="http://lh3.ggpht.com/-sVzoQRx_V2s/TlqFswXVhUI/AAAAAAAAAFc/d9nLfBSrARA/image_thumb3.png?imgmax=800" alt="img" /></p>

<p>Performance is still good at 2-5% CPU, even though we’re scrolling through 1000 items in near real-time.</p>

<p>Stay tuned for part 3, when we introduce Expression Blend and go into basics of UI design.  Also, most of this will hit GitHub very soon.</p>
]]></content>
  </entry>
  
</feed>
