<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | bling on software development]]></title>
  <link href="http://bling.github.io//blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://bling.github.io//"/>
  <updated>2013-07-22T00:47:43+00:00</updated>
  <id>http://bling.github.io//</id>
  <author>
    <name><![CDATA[Bailey Ling]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Smart tab expansions in Vim with expression mappings]]></title>
    <link href="http://bling.github.io//blog/2013/07/21/smart-tab-expansions-in-vim-with-expression-mappings/"/>
    <updated>2013-07-21T20:38:00+00:00</updated>
    <id>http://bling.github.io//blog/2013/07/21/smart-tab-expansions-in-vim-with-expression-mappings</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been having a small itch for a while now, and it&rsquo;s a very simple thing &mdash; I want to make my tab smarter.  This all starts with a dive into <a href="https://www.emmet.io">Emmet</a>.  To understand what it is, here&rsquo;s a quick introduction.  First, you type something using its syntax:</p>

<p><code>
div&gt;li*4
</code></p>

<p>and after you &ldquo;expand&rdquo; it, usually with a hotkey, and it gets converted to</p>

<p>``` html</p>

<div>
  <li></li>
  <li></li>
  <li></li>
  <li></li>
</div>


<p>```</p>

<p>As you can imagine, this saves you <em>a lot</em> of typing and lets you prototype a web page (or CSS) in no time once you learn the syntax.  It is snippets on steriods!  The Sublime <a href="https://github.com/sergeche/emmet-sublime">plugin</a> handles this perfectly.  It maps <code>&lt;tab&gt;</code> as the expansion key.  Hitting tab after typing <code>div&gt;li*4</code> will expand it and put the cursor at the first <code>&lt;li&gt;|&lt;/li&gt;</code>.  Then after you type something, if you hit <code>&lt;tab&gt;</code> again, it will jump to the next <code>li</code>.  It is smart enough to know whether to expand or jump to the next tag.</p>

<p>So how does this functionality look like in Vim?  <!--more-->First, you must install the <a href="https://github.com/mattn/zencoding-vim">zencoding-vim</a> plugin to get this functionality (Emmet used to be named Zen Coding).  However, by default it&rsquo;s mappings are <code>&lt;C-y&gt;,</code> to expand, and <code>&lt;C-y&gt;n</code> to jump to the next tag.  There are two problems here.  First, these mappings are <strong>really</strong> awkward to type.  And secondly, there are two mappings!  You could, of course, remap it do something else, but let&rsquo;s be honest, <code>&lt;leader&gt;</code> whatever just does not compare with <code>&lt;tab&gt;</code>.</p>

<p>How can we replicate this functionality in Vim?</p>

<h1>Expression Mappings</h1>

<p>Most of the time, you will see people do mappings in Vim like <code>nnoremap j gj</code> which is a very simple and straightforward mapping.  Other times you may see something like <code>nnoremap Q :call CloseWindow()&lt;cr&gt;</code> where a key is mapped to a function.  But rarely will you see anyone use <code>&lt;expr&gt;</code> mappings.  What are these?  Long story short, you can determine what to map based on the return value of the function.  To replicate the above tab behavior, let&rsquo;s first set up a basic mapping:</p>

<p><code>vim
function! s:zen_html_tab()
  return "\&lt;c-y&gt;,"
endfunction
autocmd FileType html imap &lt;buffer&gt;&lt;expr&gt;&lt;tab&gt; &lt;sid&gt;zen_html_tab()
</code></p>

<p>There&rsquo;s a lot of things going on here, so I&rsquo;ll go over them one by one.</p>

<ul>
<li><code>s:</code> denotes that the function is scoped to the script.  You can, of course, define the function globally (must be PascalCased or script#prefixed), but I prefer not to pollute the global scope if I don&rsquo;t have to.  The return value is an escaped string which are the keys you want to map.  An additional thing to note is that you need <code>&lt;sid&gt;</code> to reference the function in the mapping.</li>
<li>The FileType autocmd is used to set up the mapping only for HTML files.</li>
<li><code>&lt;buffer&gt;</code> denotes that the mapping should only apply for the current buffer (without this when you open an HTML file it will apply the mapping globally).</li>
<li><code>&lt;expr&gt;</code> is the special sauce that lets you to execute code to determine the value of the mapping.</li>
</ul>


<p>OK, the above doesn&rsquo;t actually do anything yet.  In fact, it&rsquo;s pretty much equivalent to <code>imap &lt;tab&gt; &lt;c-y&gt;,</code>.  So let&rsquo;s add some context into it:</p>

<p>``` vim
function! s:zen_html_tab()
  let line = getline(&lsquo;.&rsquo;)
  if match(line, &lsquo;&lt;.*>&rsquo;) >= &ndash;</p>

<pre><code>return "\&lt;c-y&gt;n"
</code></pre>

<p>  endif
  return &ldquo;&lt;c-y>,&rdquo;
endfunction
```</p>

<p>This is a simple implementation that captures the majority of use cases.  <code>getline('.')</code> gets the current line under the cursor.  <code>match()</code> is a built-in function which returns the index of the matched regular expression.  I am relying on the fact that Emmet syntax will <em>not</em> have an opening &lt;.  This makes the function very simple; if there&rsquo;s an &lt;> then jump to the next tag, otherwise, expand.</p>

<p>And that&rsquo;s all there is to it!  This function won&rsquo;t cover more &ldquo;advanced&rdquo; scenarios like nested expansions (although you could cheat by creating a newline), but otherwise it shows that expression mappings are an easy way to get more umph from your mappings.</p>

<p>For more details, contact your local Vim department by calling <code>:help map-&lt;expr&gt;</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The flight of an open-source project]]></title>
    <link href="http://bling.github.io//blog/2013/07/15/flight-of-an-open-source-project/"/>
    <updated>2013-07-15T10:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2013/07/15/flight-of-an-open-source-project</id>
    <content type="html"><![CDATA[<h1>Welcome aboard!</h1>

<p>Those were the words that a flight attendant said to me as a boarded a plane to visit Paris for a summer vacation of wine and cheese.  It was a long flight; about 8 hours.  This particular plane was older and didn&rsquo;t have the personal TVs installed yet.  What this meant was I didn&rsquo;t have any movies to distract me from working on a pet project I had going on.  This little project was a single vim file in my vimrc.</p>

<!--more-->


<h1>That color thing</h1>

<p>I was a huge fan of the original <a href="https://github.com/Lokaltog/vim-powerline">vim-powerline</a> project.  Even though it was purely cosmetic and didn&rsquo;t really add value (compared other plugins like <a href="https://github.com/tpope/vim-surround">vim-surround</a> where a productivity increase was measurable), I still considered it one of the most important plugins in my arsenal because I like things to look pretty.  I choose colorschemes with a lot of prejudice.  And I choose my font carefully as well (I&rsquo;m currently using Ubuntu Mono as the preferred choice).  As developers we stare at a text editor the majority of our time, and if I can make that experience a little more enjoyable then that&rsquo;s a good enough reason for me!</p>

<h1>Prologue</h1>

<p>If vim-powerline was already so good, why bother writing a replacement?  The biggest reason why I bothered was powerline <a href="https://github.com/Lokaltog/powerline">v2</a>.  This was the python rewrite of powerline which unified the codebase so that it could be used outside of vim, such as in bash, zsh, and tmux.  And just like that, vim-powerline was deprecated.</p>

<p>I was one of the early adopters because I like to use bleeding edge software.  I compile my vim to the latest tip, my preferred Linux distribution is <a href="http://www.archlinux.org">ArchLinux</a> (a rolling release distribution), and all my browsers are beta (sometimes alpha).</p>

<p>Early versions of powerline were very buggy for me to the point where I couldn&rsquo;t use it and had to fall back to vim-powerline.  It also lost a lot of features in the process, like integration with third party plugins like ctrlp and tagbar.  And lastly, installation made it very difficult to get working consistently across all operating systems.  And even within an OS, you would run into problems, e.g. system python vs homebrew python on OSX, or python3 being the default on Arch.  Ironically, I found installing on Windows the easiest of them all.</p>

<p>I started looking for alternatives and found <a href="https://github.com/molok/vim-smartusline">smartusline</a>, which is a simple statusline plugin which changes colors like powerline.  I used it for a while, but eventually I felt a strong yearning for a nicer looking statusline.  Honestly, I didn&rsquo;t have a good reason not to use vim-powerline other than the fact that it was &ldquo;old&rdquo;.  But powerline v2 wasn&rsquo;t ready yet either.  And with that I had enough of an excuse to spend my hacking hours writing statuslines.</p>

<h1>:help statusline</h1>

<p>The first working version I had was <a href="https://github.com/bling/dotvim/blob/c39021c45289d11e515bd08c1f4a976f7ba4352e/plugin/statusline.vim">65 lines</a> of code.  It was not configurable and everything was hardcoded, but it served my needs and worked pretty well.  Over time I tweaked it slowly, making small changes here and there, changing colors, and eventually using powerline font symbols.  And then I thought, wait a minute, maybe someone else might find this useful!  So on that airplane ride I decided to create a plugin out of it and share it with the community.</p>

<p><a href="https://github.com/bling/vim-airline">vim-airline</a> was born.</p>

<p>I published a link to the <a href="http://www.reddit.com/r/vim/comments/1hfbfz/vimairline_a_lightweight_statusline_light_as_air/">vim subreddit</a> and it was well received.  I got a boost to 100 stars on GitHub in a day.  Cool!  People like what I built!</p>

<h1>The first pull request</h1>

<p>The first pull request was to fix a spelling mistake where I used sep<strong>e</strong>rator instead of sep<strong>a</strong>rator.  It was also the first time I saw the big green &ldquo;Merge Pull Request&rdquo; button on GitHub.  And let me tell you that entire process is nothing short of amazing.  It is so damn easy to collaborate I wish I had this at work.</p>

<p>And then issues started coming in; bugs and feature requests.  More pull requests were submitted, some to fix bugs, others to fix performance problems.  I had my little open source project going and it was so much fun!  And people were open to suggestions, code reviews, and just generally very receptive to discussion.  It was awesome!</p>

<p>I continued working on the plugin to add theming support, and once I finished I posted it to <a href="https://news.ycombinator.com/item?id=6002518">HackerNews</a>.</p>

<h1>A lesson in marketing</h1>

<p>It sounds obvious now after the fact, but I didn&rsquo;t really realize what a big difference marketing makes.  Last year I made a relatively significant contribution to the WPF world &mdash; I added <a href="http://bling.github.io/blog/2012/07/01/snoopshell-marriage-of-snoop-wpf-and/">PowerShell to Snoop</a>.  Snoop is a staple tool for any WPF developer, and for my work to be accepted and merged into the main product was really quite something.  After many retweets, my fork acquired a whopping 6 stars.  The reason?  My target audience was C# developers who did WPF, <em>and</em> who used PowerShell.  It was tiny market!</p>

<p>vim-airline is different.  The market is all terminal users, which is a <strong>huge</strong> market.  It didn&rsquo;t matter if you were doing sysadmin work scripting the shell or developing a website in JavaScript or deploying a distributed cluster using Ruby.  Somebody would be using vim, and furthormore, because airline was written in 100% VimScript it worked for everyone.</p>

<p>After I posted it to HackerNews, momentum <strong><em>really</em></strong> picked up and a flood of bugs and feature requests came in.  A lot of people also starting writing themes for it, which validated my claim that it was easy to do.  The project gained another 200-300 stars overnight.</p>

<h1>Murphy&rsquo;s Law</h1>

<p>Last Tuesday night, vim-airline became the default in the <a href="http://vim.spf13.com/">spf13</a> distribution, which is one of the most popular distributions out there.  On that same night, I <a href="https://github.com/bling/vim-airline/commit/c0427e435d2eb2170517438ddd4f0b5fa7a8b691">pushed</a> a change to improve the extendability of the plugin.  It was the last thing I did that night and I went to bed shortly after.  Everything that could go wrong, went wrong &mdash; I woke up to a flurry of emails about it breaking in the most <a href="https://github.com/bling/vim-airline/issues/49">catastrophic</a> <a href="https://github.com/bling/vim-airline/issues/45">way</a> <a href="https://github.com/spf13/spf13-vim/issues/397">possible</a>.  I jumped from my bed to the computer in record time to revert that change.  After a lot of (manual) investigation, I narrowed it down to the exact <a href="https://code.google.com/p/vim/source/detail?r=66e615ce7f61948a2a4a8615d703a42d56763490&amp;name=v7-3-1058">patch</a> (1058) in Vim that affected my code.  That&rsquo;s what I get for using bleeding edge software&hellip;</p>

<p>Since this incident I&rsquo;ve been testing with Vim 7.2 prior to pushing any code changes to the core.</p>

<h1>Destination to be determined&hellip;</h1>

<p>Popularity continued to grow, and as of now, after being live for only 2 weeks, the project has 772 stars, 36 forks, and 15 contributors.  6 themes have been contributed.</p>

<p>It&rsquo;s hard to describe the feeling I&rsquo;m having &mdash; I guess I&rsquo;m just really thrilled to have so many people take interest in something I built.  I had no idea it would be this popular, and now I&rsquo;m just trying to keep up with the issues.</p>

<p>The community aspect of open source is incredible.  I don&rsquo;t know where the project will go from here, but for the time being, I&rsquo;m going to sit back, relax, and enjoy the flight.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unite.vim, The plugin you didn't know you need]]></title>
    <link href="http://bling.github.io//blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/"/>
    <updated>2013-06-02T19:34:00+00:00</updated>
    <id>http://bling.github.io//blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need</id>
    <content type="html"><![CDATA[<h1><a href="https://github.com/Shougo/unite.vim">Unite.vim</a></h1>

<p>What is this?  If you&rsquo;ve never heard of this Vim plugin, then this post is for you.  This is one of those hidden gems in the Vim plugin world that is truly life changing.  I think this plugin is so awesome that I&rsquo;ve decided to write a post dedicated to it so that more people know about it.</p>

<p>The plugin is written by <a href="https://github.com/Shougo">Shougo Matsushita</a>.  He has written a lot of other popular plugins, notably <a href="https://github.com/Shougo/neocomplcache.vim">neocomplcache</a> and <a href="https://github.com/Shougo/vimshell.vim">vimshell</a>.  I use a lot of his plugins, so I started to notice when certain plugins started using Unite as a dependency, like <a href="https://github.com/Shougo/neobundle.vim">neobundle</a> and <a href="https://github.com/Shougo/vimfiler.vim">vimfiler</a>.</p>

<p>At first it looked like Unite was just a general purpose library, but I was in for a surprise because it is so much more than that.</p>

<!--more-->


<h1>What is it?</h1>

<p>This is the problem I had initially.  The project <a href="https://github.com/Shougo/unite.vim">homepage</a> describes it as &ldquo;&hellip;can search and display information from arbitrary sources like files, buffers, recently used files or registers.&rdquo;  It goes on to show some usage samples, but there is no &ldquo;wow&rdquo; factor.  After reading the readme I still didn&rsquo;t have a clue what the plugin could do.</p>

<p>(edit: After I wrote blog post, Unite&rsquo;s homepage has been dramatically improved with screenshots, animated gifs, and even a kickass logo.  It definitely has a lot of &ldquo;wow&rdquo; now.)</p>

<p>It wasn&rsquo;t until I stumbled upon terryma&rsquo;s <a href="https://github.com/terryma/dotfiles/blob/master/.vimrc">vimrc</a> (the author of <a href="https://github.com/terryma/vim-multiple-cursors">multiple-cursors</a> and realized that he replaced <a href="https://github.com/kien/ctrlp.vim">ctrlp</a> entirely with unite).  ctrlp is by far one of the best/most popular plugins and for it to be replacable is no easy feat.</p>

<p>So how do you do it?</p>

<h1>First things first, configuration</h1>

<p>Unite is geared towards experienced vim users &mdash; it does not create any bindings by default.  To make any use of it, you will need to create the bindings yourself.  And in certain cases, rather than declaring <code>g:variables</code>, you configure it with method calls, like <code>unite#filters#matcher_default#use(['matcher_fuzzy'])</code>, but thankfully, like all of Shougo&rsquo;s plugins, the plugin is <em>very</em> well documented, so feel free to <code>:help unite</code> to figure out how to use the plugin.</p>

<p>If you&rsquo;re lazy, you can go directly to my <a href="https://github.com/bling/dotvim">vim distribution</a> and take the configuration out of there.</p>

<p>But enough talking, here&rsquo;s some quick demos of what Unite can do&hellip;</p>

<h1>What can it do?</h1>

<h2>File searching like <a href="https://github.com/kien/ctrlp.vim">ctrlp.vim</a></h2>

<p><code>
nnoremap &lt;C-p&gt; :Unite file_rec/async&lt;cr&gt;
</code></p>

<p><img class="center" src="/images/unite-ctrlp.gif"></p>

<p>Did you notice the async flag?  Unite uses <a href="https://github.com/Shougo/vimproc.vim">vimproc</a> behind the scenes, which affords for searching while it populates the file list in the background.  That is amazing!</p>

<h2>Content searching like <a href="https://github.com/mileszs/ack.vim">ack.vim</a> (or <a href="https://github.com/rking/ag.vim">ag.vim</a>)</h2>

<p><code>
nnoremap &lt;space&gt;/ :Unite grep:.&lt;cr&gt;
</code></p>

<p><img class="center" src="/images/unite-grep.gif"></p>

<p>Unite can be configured to use <code>grep</code>, <code>ack</code>, or <code>ag</code>; whichever is available.</p>

<h2>Yank history like <a href="https://github.com/vim-scripts/YankRing.vim">yankring</a>/<a href="https://github.com/maxbrunsfeld/vim-yankstack">yankstack</a></h2>

<p><code>
let g:unite_source_history_yank_enable = 1
nnoremap &lt;space&gt;y :Unite history/yank&lt;cr&gt;
</code></p>

<p><img class="center" src="/images/unite-yanks.gif"></p>

<p>To be fair, unite cannot bind to a key to cycle the history, so it&rsquo;s not a 100% replacement.  However, if you only rarely use the yankring then this is a pretty good alternative.</p>

<h2>Buffer switching like <a href="https://github.com/sjbach/lusty">LustyJuggler</a></h2>

<p><code>
nnoremap &lt;space&gt;s :Unite -quick-match buffer&lt;cr&gt;
</code></p>

<p><img class="center" src="/images/unite-juggle.gif"></p>

<p>Notice that <code>-quick-match</code> is just a flag, which means you can apply this to any source.</p>

<h2>Bonus</h2>

<p>Ever been jealous of Sublime&rsquo;s auto preview feature?  Well, turns out unite has an <code>-auto-preview</code> flag that you can add.</p>

<h1>Finale</h1>

<p>And that&rsquo;s all I got for now.  I&rsquo;m still learning more about what this plugin can do, but it&rsquo;s definitely earned its place in my vim toolbox.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Macros with Vim]]></title>
    <link href="http://bling.github.io//blog/2013/02/11/writing-macros-with-vim/"/>
    <updated>2013-02-11T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2013/02/11/writing-macros-with-vim</id>
    <content type="html"><![CDATA[<p>First, let’s start with a Javascript function:
``` javascript
function foo(hello, world,</p>

<pre><code>         how, are,
         you) {
</code></pre>

<p>}
<code>
Now let’s convert that to the following:
</code> javascript
function foo(parameters) {</p>

<pre><code>var hello = parameters.hello;
var world = parameters.world;
var how = parameters.how;
var are = parameters.are;
var you = parameters.you;
</code></pre>

<p>}
<code>
Here are the macros I used to do this:
</code> vim
let @r=&lsquo;di(iparameters^[/{^M2o^[kpg<code>[v</code>]Jgv:s/\s//g<sup>M0</sup>:try|exe &ldquo;norm! @q&rdquo;|endtry<sup>MA</sup>;^[V:s/,/;\r/g<sup>Mv</sup>``=&rsquo;
let @q=&lsquo;ywivar ^[pa = parameters.^[f,^[l@q&rsquo;
```</p>

<!--more-->


<p>Note that if you copy paste the above into your vimrc it will not work. The <code>^[</code> and <code>^M</code> found are actually single characters, not two. To input this properly you will need to chord it in input mode with <code>&lt;Ctrl-V&gt;</code>. So for <code>&lt;Esc&gt;</code> you would chord <code>&lt;Ctrl+V&gt;&lt;Ctrl+[&gt;</code>.</p>

<p>So, when I&rsquo;m inside the parameters of the function, I can hit <code>@r</code> and it will perform the refactoring. Now let’s break it down step by step.</p>

<h1>@q The first macro</h1>

<p>This is a recursive macro which takes something like <code>a,b,c</code> and turns it into <code>var a = p.a,var b = p.b,var c = p.c</code>. Let’s see how that’s done.</p>

<ol>
<li><code>yw</code> <code>i</code> <code>var</code> <code>&lt;Esc&gt;</code> <code>p</code> Yanks the word and enter insert mode, type var, exit insert mode and paste the just yanked word.</li>
<li><code>a = parameters.</code> Append and fill in parameters.</li>
<li><code>&lt;Esc&gt;</code> <code>f</code>, <code>l</code> Exit insert mode, find the next <code>,</code></li>
<li><code>l</code> <code>@q</code> Adjust the cursor position and recursively call itself.</li>
</ol>


<p>Recursive macros terminate when the first error occurs. In this macro, that error is when there are no more commas left.</p>

<h1>@r The second macro</h1>

<p>The is the macro that should be invoked, and references the <code>@q</code> macro.</p>

<ol>
<li><code>di(</code> Deletes everything inside the brackets.</li>
<li><code>i</code> parameters Enter insert mode and type parameters.</li>
<li><code>&lt;Esc&gt;</code> <code>/{</code> <code>&lt;CR&gt;</code> Leaves insert mode and finds the next brace.</li>
<li><code>2o</code> <code>&lt;Esc&gt;</code> <code>k</code> <code>p</code> Creates two empty lines and pastes what we deleted into the first line.</li>
<li><code>g`[v`]</code> <code>J</code> Visually select what we just pasted and join them all into a single line.</li>
<li><code>gv</code> <code>:s/\s//g</code> <code>&lt;CR&gt;</code> Reselect the visually and delete all whitespace.</li>
<li><code>0</code> Move to the beginning of the line.</li>
<li><code>:try|exe "norm! @q"|endtry</code> <code>&lt;CR&gt;</code> Macros will terminate on the first error, even if referencing another macro. Wrapping the other macro with try|endtry swallows the error and lets the current macro continue.</li>
<li><code>A;</code> <code>&lt;Esc&gt;</code> Append ; to the end of the line.</li>
<li><code>V</code> <code>:s/,/;\r/g</code> <code>&lt;CR&gt;</code> Visually select the line, replace with carriage returns.</li>
<li><code>v=``</code>  Visually select from the current cursor position back to where it was originally was, and format.</li>
</ol>


<p>Now is this the best way to do it? Probably not. I would not be surprised if someone was able to do it with less keystrokes or a single macro.  But hey, it was fun learning experience, and ultimately I turned all of that into two keystrokes that can be reused many times.</p>

<p>I posted this on <a href="http://vimgolf.com/challenges/511991607729fb0002000003">vimgolf</a> so let’s see how other people solved the same refactoring!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Love Affair with Vim]]></title>
    <link href="http://bling.github.io//blog/2013/02/10/love-affair-with-vim/"/>
    <updated>2013-02-10T00:00:00+00:00</updated>
    <id>http://bling.github.io//blog/2013/02/10/love-affair-with-vim</id>
    <content type="html"><![CDATA[<p>It wasn&rsquo;t too long ago when I was a full-time C# developer and my environment was Visual Studio eight hours a day.  Then, I became a web developer over night cold turkey writing Javascript and CSS.  It&rsquo;s one of the benefits of working for a consulting company.</p>

<p>You might think what does that have to do with the title of this post?  Well, originally my plan was to write a blog post contrasting on the differences between Javascript and C#, as well as the development environments and deployment platforms.  But really, what I really wanted to write about was Vim.</p>

<p>Moving from Visual Studio to Vim was a progression through different editors and environments.  The first thing I used to write Javascript was Webstorm.  Over time I realized that you didn&rsquo;t really need an IDE to write Javascript/CSS.  Then, I used Sublime Text for a little bit.  But ultimately, I settled on Vim, and stayed there.</p>

<p>My stubbornness turned out to be beneficial when I was learning Vim because the first month was absolutely painful.  I remapped all of my arrows keys to do nothing to force myself to use hjkl.  Eventually I got the hang of it, and now I definitely have the muscle memory that makes me much more productive when editing (and reading) text.</p>

<!--more-->


<p>By default Vim is just a text editor.  But I work on a project, so like most lazy people I searched for prepackaged plugins and came across two popular distributions: <a href="https://github.com/spf13/spf13-vim">spf13</a> and <a href="https://github.com/carlhuda/janus">janus</a>.  When I installed them, it was like someone took over Vim and made it change into a completely different beast.  I didn&rsquo;t know how to use it anymore.</p>

<p>I took a step back.  I forgot where I got this advice, but I think anyone using Vim needs to do this: <em>start your own vimrc from scratch</em>.</p>

<p>I took a look at all the settings that spf13 and janus changed.  I copied them to my vimrc <em>one by one</em>, and also <code>:help</code>ing each setting so that I knew exactly what it changed.  I must say, Vim&rsquo;s documentation is some of the best and most comprehensive of any tool I&rsquo;ve worked with.  It was incredibly helpful in my progression.</p>

<p>Then, I did the same thing for plugins.  And the nice thing was that most plugins followed the Vim pattern of having good documentation.  After installing <code>fooplugin</code>, I just <code>:help fooplugin</code> and I got all the information I needed to know about the plugin.</p>

<p>I became obsessed with optimizing my vimrc, and trying out different plugins on a daily basis.  And because I was very adamant with trying one plugin at a time, I got to know them very well.  I knew about how to turn certain settings on and off, how to configure their bindings, and more importantly, how it interacted with all of the other plugins I have already installed.  Over time my vimrc became a full blown distribution in its own right, highly customized to my personal work habits.</p>

<p>However, even though I recommend that anyone interested in taking their Vim skills to the next level should do this discovery that I have done, there are certainly classes of plugins that I deem to be <em>must-have</em> for any Vim user and I wanted to highlight them here.</p>

<h1>Plugin Management</h1>

<p>First things first you will need one plugin to rule them all!  <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> changed the way people install plugins by utilizing git submodules.  This has the pros and cons of git submodules, i.e. they track a specific version of the external git repository, so if external plugins are updated frequently you have to manually update all your submodules.</p>

<p>However, more often than not, you just want the latest version.  <a href="https://github.com/gmarik/vundle">Vundle</a> takes the management one step further and will automatically grab source code from Github for you (as well as automatically updating everything to the latest version).</p>

<p>The last one and least known is <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a>, which is like Vundle on steroids.  It adds a whole ton of new features like allowing you to specify installation steps for compiling something.</p>

<h1>Fuzzy File Searching</h1>

<p>This was the major game changer for me and changed the way I worked.  Naturally, proper Vim technique forces your hands to be on the home row, which makes reaching for the mouse (or even the arrow keys) to be inefficient.  Therefore, the fastest way to open a file is usually to type its name.</p>

<p><a href="https://github.com/wincent/Command-T">CommandT</a> (written in Ruby) is noticeably much faster than <a href="https://github.com/kien/ctrlp.vim">CtrlP</a> (pure VimScript), but CtrlP has a lot more features.  There&rsquo;s also <a href="http://www.vim.org/scripts/script.php?script_id=1984">FuzzyFinder</a>, which I have not tried.</p>

<h1>Autocomplete and Snippets</h1>

<p>There are various contenders here.  Generally, you&rsquo;ll find that people fall into two camps.</p>

<ol>
<li><a href="https://github.com/garbas/vim-snipmate">Snipmate</a>/<a href="https://github.com/SirVer/ultisnips">UltiSnips</a> + <a href="https://github.com/ervandew/supertab">SuperTab</a> + <a href="http://www.vim.org/scripts/script.php?script_id=1879">AutoComplPop</a></li>
<li><a href="https://github.com/Shougo/neocomplcache">neocomplcache</a> + <a href="https://github.com/Shougo/neosnippet">neosnippet</a></li>
</ol>


<p>Snipmate is an older implementation of snippets which is getting replaced with UltiSnips.  Supertab gives you an easy way to trigger omnicompletion with (you guessed it) tab, and AutoComplPop is for automatically showing the popup as you type.</p>

<p>Neocomplcache is a very powerful completion plugin.  It runs a little slower than SuperTab because it does a lot more, but I find the performance acceptable so that&rsquo;s what I&rsquo;m using.  And I choose neosnippet over the others simply because it&rsquo;s by the same author and thus has better integration (e.g. available snippets will appear in the list).</p>

<p>And of course, a good collection of snippets like <a href="https://github.com/honza/vim-snippets">honza</a>&rsquo;s collection.</p>

<p><em>edit</em>: Since I last posted this another autocomplete plugin has taken the Vim world by storm.  It is none other than <a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>.  This is a fantastic plugin which shows a lot of promise.  It does not have as many features as neocomplcache yet, but it is improving every day and has a large community gathering around it.  Things can only get better!</p>

<p><em>edit 2</em>: <a href="https://github.com/Shougo/neocomplete.vim">neocomplete</a> is the next generation version of neocomplcache, and despite being in its infancy is showing great progress and has most (if not all) of the features of neocomplcache.  It requires you to recompile vim with lua support, but has the added benefit that it is way faster than before, and unlike YouCompleteMe (which officially does not support Windows), it works very well on Windows as well.</p>

<h1>And that&rsquo;s it!</h1>

<p>What?!  No file browser?  No buffer manager?  Yes, I have all of those installed as well.  In fact, I have over 50 plugins installed in total.  But in my opinion, they are not <em>killer</em> features.  I can live without them.  But if I didn&rsquo;t have fuzzy searching or completion/snippets, I would feel a little too naked.</p>

<p>Out of the box Vim has some interesting defaults, mainly for backwards compatibility with Vi, but I think it&rsquo;s safe to say that anyone who uses Vim seriously will have a custom vimrc.  If you&rsquo;re just starting out and don&rsquo;t know what to change, <a href="https://github.com/tpope/vim-sensible">sensible</a> is a good set of defaults.</p>

<p>Vim has changed my work habits dramatically.  I think and dream Vim.  I install Vim plugins in my browsers.  And every day, she still teaches me new tricks.  It&rsquo;s quite exhilarating!</p>

<p>If you&rsquo;ve read until this point you might be interested in the full set of plugins that I&rsquo;m using.  If so, head over to my <a href="http://bling.github.com/dotvim/">vim distribution project</a>!</p>
]]></content>
  </entry>
  
</feed>
