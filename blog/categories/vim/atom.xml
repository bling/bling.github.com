<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | bling on software development]]></title>
  <link href="http://bling.github.io/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://bling.github.io/"/>
  <updated>2013-10-16T13:19:23-04:00</updated>
  <id>http://bling.github.io/</id>
  <author>
    <name><![CDATA[Bailey Ling]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Emacs as my Leader: evil-mode]]></title>
    <link href="http://bling.github.io/blog/2013/10/16/emacs-as-my-evil-mode/"/>
    <updated>2013-10-16T12:54:00-04:00</updated>
    <id>http://bling.github.io/blog/2013/10/16/emacs-as-my-evil-mode</id>
    <content type="html"><![CDATA[<p>Hey guys, I just wanted to post a quick demo video on <a href="https://gitorious.org/evil">evil-mode</a>.</p>

<p>The video is targetted at intermediate/advanced Vim users, so if you&rsquo;re just starting out you might miss some things. But&hellip;hopefully it&rsquo;ll be an enjoyable watch regardless!</p>

<iframe width="630" height="473" src="http://bling.github.io//www.youtube.com/embed/Uz_0i27wYbg" frameborder="0" allowfullscreen></iframe>


<p>Let me know what you guys think of it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim in Emacs Bootstrap]]></title>
    <link href="http://bling.github.io/blog/2013/09/09/vim-in-emacs-bootstrap/"/>
    <updated>2013-09-09T20:00:00-04:00</updated>
    <id>http://bling.github.io/blog/2013/09/09/vim-in-emacs-bootstrap</id>
    <content type="html"><![CDATA[<p>Did I wake up on the wrong side of the bed?</p>

<p>My New Year&rsquo;s resolution for 2013 was to learn Vim. I was so new to Vim that I did not even know how to <a href="http://stackoverflow.com/questions/14107198/vim-delete-whitespace-between-2-lines">join lines</a> properly. However, I was diligent, patient, and stubborn enough to stick at it. It didn&rsquo;t take long for me to <a href="http://bling.github.io/blog/2013/02/10/love-affair-with-vim">fall in love</a>. I even ended up writing a <a href="https://github.com/bling/vim-airline">plugin</a> for Vim that got so popular that I was writing VimL as a second job.</p>

<p>Sounds like I&rsquo;m pretty happy with Vim (and I am), so why am I trying Emacs?</p>

<p>Curiosity is a major reason. But more I think the philosophy of Emacs fits my personality better. The Vim community is very much divided into two camps: the text editor people, and the people who try to turn Vim into an IDE. I am in the latter. My vim <a href="https://github.com/bling/dotvim">distribution</a> has over 90 plugins. While I haven&rsquo;t yet run into Vim&rsquo;s limitations of trying to use it this way, I can already see the walls coming up&hellip;</p>

<p>But here&rsquo;s the thing, I&rsquo;m addicted to <strong>modal editing</strong>, not Vim.<!-- more --> It just so happens that Vim is the best implementation of modal editing, but Emacs has something that does a pretty damn good job too! And it&rsquo;s none other than <a href="http://www.emacswiki.org/emacs/Evil">evil-mode</a>.</p>

<p>With evil-mode, it&rsquo;s finally possible to have the best of both worlds. The power of modal editing with the near limitless extensibility of Emacs.</p>

<p>And as an added bonus I can finally have an excuse to learn a Lisp dialect. I discovered with Vim that customizing your editor is an incredible catalyst for learning a new language. It wasn&rsquo;t my intention to memorize a sizable portion of the VimL standard library when I started using Vim, but it happened anyway once I started tweaking and customizing&hellip;</p>

<p>My goal is that by the end of this post you&rsquo;ll have a working Emacs installation with Vim keybindings out of the box.</p>

<h1>Back to Basics</h1>

<p>The best way to learn is to start from scratch. And so I did exactly that starting with the built-in tutorial <code>C-h t</code>. While the purpose of this blog post is to get modal editing working in Emacs, you&rsquo;re not going to be able to make <em>everything</em> modal, so you still need to know basic commands to navigate around.</p>

<h1>Things you need to know</h1>

<p>There are a couple important Emacs keys that you should know.</p>

<ul>
<li><code>C-g</code> is the universal &ldquo;get me out of here&rdquo; key, equivalent to <code>C-c</code> in Vim.</li>
<li><code>C-h</code> is the &ldquo;help&rdquo; prefix. <code>C-h C-h</code> will show you all possible options. I&rsquo;ve found that I use <code>C-h f</code> very often, which is used to lookup help for functions.</li>
<li><code>C-x</code> is a also very important, as it&rsquo;s the prefix for many common things like saving and finding files.</li>
<li><code>C-c</code> by <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html">convention</a> are used for many things, including the equivalent of <code>&lt;leader&gt;</code> for user customizations when followed by letters, but also for major and minor mode bindings.</li>
</ul>


<h1>Setting up your &ldquo;vimrc&rdquo;</h1>

<p>In Emacs, this is the <code>~/.emacs</code> file. But just like in Vim, where you usually have a <code>~/.vim</code> directory for various plugins and configuration, Emacs has the <code>~/.emacs.d</code> directory. As an added bonus, <code>~/.emacs.d/init.el</code> is automatically loaded, so if you put your dotfiles up on GitHub it&rsquo;s as simple as cloning it to <code>~/.emacs.d</code>.</p>

<h1>What&rsquo;s with the (((())))?</h1>

<p>Going through the documentation is one thing, but making the first change to your <code>~/.emacs.d/init.el</code> file is daunting, at least for me it was. While Vim also has its own scripting language, VimL, it is much more newbie friendly.</p>

<p>How do you turn on line numbers? You add <code>set number</code> to your vimrc. It&rsquo;s simple, straightforward, and obvious. You don&rsquo;t even know you&rsquo;re scripting in Vim; it just looks like a configuration file at this point. How do you do that in Emacs? First you search on Google, which links you to this <a href="http://www.emacswiki.org/emacs/LineNumbers">EmacsWiki</a> article. If that doesn&rsquo;t scare you from using Emacs I don&rsquo;t know what will.</p>

<p>The short answer is, you add <code>(global-linum-mode t)</code> to your <code>init.el</code> file. Right off the bat the questions would be, is that a variable, a function? What is <code>t</code>?</p>

<p>Configuring Emacs throws you into Lisp from the get go, so what you want to do is actually read <a href="http://www.gnu.org/software/emacs/manual/eintr.html">Introduction to Programming in Emacs Lisp</a>.</p>

<h1>Lisp basics</h1>

<p>You&rsquo;re going to be seeing a lot of Lisp, so let&rsquo;s summarize the basics:</p>

<ul>
<li><code>set</code> will set a variable, but you will rarely see this.</li>
<li><code>setq</code> is <em>very</em> frequently seen. The q stands for quote, which will sidetrack you to understanding what a <a href="http://stackoverflow.com/questions/134887/when-to-use-quote-in-lisp">quote</a> is.</li>
<li><code>setq-default</code> sets a variable if it&rsquo;s not already set/overridden.</li>
<li><code>defun</code> defines a function.</li>
<li><code>-p</code> by convention is added to functions that return true or false (the p stands for predicate).</li>
</ul>


<p>Now that things are a bit more readable, we can begin setting up our configuration to get evil-mode installed.</p>

<h1>Package management</h1>

<p>Emacs 24 comes with built-in <a href="http://www.emacswiki.org/emacs/ELP">package management</a>. The default GNU repository doesn&rsquo;t really have many packages, but luckily there&rsquo;s a community driven repository named <a href="http://melpa.milkbox.net/">MELPA</a> where up to date packages are built directly from GitHub.</p>

<p>So, let&rsquo;s add the MELPA into our <code>~/.emacs.d/init.el</code> file:</p>

<p>``` cl
;;; this loads the package manager
(require &lsquo;package)</p>

<p>;;; here there&rsquo;s a variable named package-archives, and we are adding the MELPA repository to it
(add-to-list &lsquo;package-archives</p>

<pre><code>         '("melpa" . "http://melpa.milkbox.net/packages/") t)
</code></pre>

<p>;;; loads packages and activates them
(package-initialize)
```</p>

<p>OK, straightforward so far.</p>

<h1>Installing evil</h1>

<p>Next up is the all important <code>M-x</code> binding (on modern keyboards M is the Alt key). This is sort of like Vim&rsquo;s <code>:</code> where you can type commands. Here we are going to do a <code>M-x package-refresh-contents RET</code>. In Emacs, <code>RET</code> is the convention for <code>&lt;CR&gt;</code>. This will refresh the repository of available packages. And finally, <code>M-x package-install RET evil RET</code>.</p>

<p>And now it&rsquo;s installed!</p>

<p>It&rsquo;s not enabled by default, so we need to append the following lines to our <code>init.el</code> file:</p>

<p><code>cl
(require 'evil)
(evil-mode t)
</code></p>

<p>Finally, <code>C-x C-c</code> to quit Emacs and restart it. If you&rsquo;re feeling adventurous you can use <code>M-x eval-buffer RET</code> instead.</p>

<h1>Finale</h1>

<p>Congratulations! You have a working Emacs installation with Vim modal editing!</p>

<p>You may notice that in addition to <code>C-c</code>, <code>C-h</code>, and <code>C-x</code> that I mentioned earlier, <code>C-u</code> will not scroll up half a page as you would expect. This is because by default this is mapped to the Emacs <code>universal-argument</code> function, which is used for repeating. You can of course customize all of this, but I&rsquo;ll let you take it from here&hellip;</p>

<p>And so there you have it!</p>

<p>TLDR: <code>git clone https://github.com/bling/emacs-evil-bootstrap.git ~/.emacs.d</code> will automate this entire blog post and let you try Vim in Emacs in 10-20 seconds.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modularizing VimScript]]></title>
    <link href="http://bling.github.io/blog/2013/08/16/modularizing-vimscript/"/>
    <updated>2013-08-16T20:22:00-04:00</updated>
    <id>http://bling.github.io/blog/2013/08/16/modularizing-vimscript</id>
    <content type="html"><![CDATA[<h1>The prerequisites</h1>

<p>First off, there are two very good resources that are required reading in addition to what&rsquo;s provided in the official documentation.  Steve Losh&rsquo;s <a href="http://learnvimscriptthehardway.stevelosh.com/">Learn Vim the Hard Way</a> is an excellent book and I highly recommend it.  The <a href="http://www.ibm.com/developerworks/library/l-vim-script-1/">IBM Series</a> by Dr. Damian Conway is another great resource.  Without these I would not have been able to do what I have achieved, so thanks to them!</p>

<h1>Where I started</h1>

<p>When I first wrote <a href="https://github.com/bling/vim-bufferline">vim-bufferline</a> and <a href="https://github.com/bling/vim-airline">vim-airline</a> I was very much a newbie Vim scripter and I tried to follow as many existing patterns as possible.  It was evident that the community at large had a very &ldquo;C-like&rdquo; mentality, in that most things were done with functions declared in the global scope (I don&rsquo;t know if this still holds true for modern C development, but as an expression I think people will get what I&rsquo;m saying).  Many of the older scripts (pre GitHub) tended to be large, single file plugins which lived under the <code>plugin</code> folder.  For example, <a href="http://www.vim.org/scripts/script.php?script_id=2438">EasyGrep</a> is a 3000+ line plugin that helps you search and replace in Vim.</p>

<!-- more -->


<p>Most tutorials also taught writing functions in this fashion (most likely due to simplicity).  For example, this is from <a href="http://www.ibm.com/developerworks/library/l-vim-script-1/">part 1</a> of the IBM developer series:</p>

<p>``` vim
function! ToggleSyntax()
   if exists(&ldquo;g:syntax_on&rdquo;)</p>

<pre><code>  syntax off
</code></pre>

<p>   else</p>

<pre><code>  syntax enable
</code></pre>

<p>   endif
endfunction
nmap <silent> ;s :call ToggleSyntax()<CR>
```</p>

<p>We all have to start somewhere, but what I found was that these patterns and practices followed beyond their original intention and into plugins.</p>

<p>I think part of the problem is that Vim has a very unique scoping system, in that you can scope variables to a script, window, or buffer, for example.  People ended up using this as a form of encapsulation:</p>

<p>`&ldquo; vim
let s:text = &rdquo;</p>

<p>function! s:somefile#set_text(val)
  let s:text = a:val
endfunction</p>

<p>function! g:somefile#get_text()
  return s:text
endfunction
```</p>

<p>The <code>g:</code> variables are your exposed public API, and the <code>s:</code> variables are private.  That&rsquo;s all good, but <em>everything is still global!</em></p>

<h1>Where I am now</h1>

<p>There is nothing particular wrong with the approach of using global variables and functions.  Many complex software systems have been designed this way with much success, and often times, they perform much faster than counterparts with &ldquo;objects&rdquo; and &ldquo;polymorphism&rdquo;.</p>

<p>Nonetheless, everything has pros and cons, and the cost of maintenance goes up when you have a bunch of global variables interacting with each other.</p>

<p>The more VimScript I wrote the more I sought for a way to manage complexity and splitting up my code into smaller, manageable pieces.</p>

<h1>Modularizing VimScript</h1>

<p>Let&rsquo;s take a look at how we can create an object that is transient, has state, and contains methods you can invoke, like any modern OOP language can do.</p>

<p>``` vim
function! myobject#new()
  let obj = {}
  let obj._cats = []</p>

<p>  function! obj.add_cat()</p>

<pre><code>call add(self._cats, '(^.^)')
</code></pre>

<p>  endfunction</p>

<p>  function! obj.meow()</p>

<pre><code>for cat in self._cats
  echo cat
endfor
</code></pre>

<p>  endfunction</p>

<p>  return obj
endfunction</p>

<p>&ldquo; somewhere else
let x = myobject#new()
call x.add_cat()
call x.meow()
```</p>

<p>This might look familiar to some of you.  Yes, it&rsquo;s almost the same as the <a href="https://www.google.com/search?q=javascript+module+pattern">JavaScript Module Pattern</a>.  Unfortunately, closures are not supported, but otherwise all of the usual benefits apply here, mainly controlled visibility into private state <strong>and</strong> <strong><em>transience!</em></strong></p>

<p>You can even take this concept further and replicate &ldquo;static&rdquo; functions:</p>

<p>``` vim
function! s:object#private_static()
endfunction</p>

<p>function! g:object#public_static()
endfunction</p>

<p>function! g:object#new()
  let obj = {}</p>

<p>  function! obj.public()
  endfunction</p>

<p>  function! obj._private()
  endfunction</p>

<p>  return obj
endfunction
```</p>

<p>Yep, same story as JavaScript here &mdash; <code>_</code> variables/functions are &ldquo;private&rdquo;.</p>

<h1>Where from here?</h1>

<p>Does this mean we should throw out procedural programming and go full on object oriented?  Hell no.  <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html">This</a> is what happens when you go too far!  But we should always take a look at what we&rsquo;re doing and use the best tool and technique for the job.  Sometimes that&rsquo;s procedural, other times it&rsquo;s object-oriented.  It pays to be flexible.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1000 stars in 1 month]]></title>
    <link href="http://bling.github.io/blog/2013/07/30/1000-stars-in-1-month/"/>
    <updated>2013-07-30T21:26:00-04:00</updated>
    <id>http://bling.github.io/blog/2013/07/30/1000-stars-in-1-month</id>
    <content type="html"><![CDATA[<h1>1000 stars in 1 month</h1>

<p>One month ago I pushed the first <a href="https://github.com/bling/vim-airline/commit/25b9d4d48bd8c0a3daf3859998825e2e55562f70">commit</a> of my plugin <a href="https://github.com/bling/vim-airline">vim-airline</a>.</p>

<p>Two weeks later I wrote a blog <a href="http://bling.github.io/blog/2013/07/15/flight-of-an-open-source-project/">post</a> about the experience.  By that time the plugin gained over 700 stars.</p>

<p>Two more weeks later, today the project has over 1000 stars.  Here are some other numbers:</p>

<ul>
<li>35 merged pull requests</li>
<li>8 contributed airline themes</li>
<li>4 contributed ctrlp themes</li>
<li>23 total contributors</li>
<li>15 plugins integrated</li>
</ul>


<p>Wow!  That is all I can say&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smart tab expansions in Vim with expression mappings]]></title>
    <link href="http://bling.github.io/blog/2013/07/21/smart-tab-expansions-in-vim-with-expression-mappings/"/>
    <updated>2013-07-21T20:38:00-04:00</updated>
    <id>http://bling.github.io/blog/2013/07/21/smart-tab-expansions-in-vim-with-expression-mappings</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been having a small itch for a while now, and it&rsquo;s a very simple thing &mdash; I want to make my tab smarter.  This all starts with a dive into <a href="http://www.emmet.io">Emmet</a>.  To understand what it is, here&rsquo;s a quick introduction.  First, you type something using its syntax:</p>

<p><code>
div&gt;li*4
</code></p>

<p>and after you &ldquo;expand&rdquo; it, usually with a hotkey, and it gets converted to</p>

<p>``` html</p>

<div>
  <li></li>
  <li></li>
  <li></li>
  <li></li>
</div>


<p>```</p>

<p>As you can imagine, this saves you <em>a lot</em> of typing and lets you prototype a web page (or CSS) in no time once you learn the syntax.  It is snippets on steriods!  The Sublime <a href="https://github.com/sergeche/emmet-sublime">plugin</a> handles this perfectly.  It maps <code>&lt;tab&gt;</code> as the expansion key.  Hitting tab after typing <code>div&gt;li*4</code> will expand it and put the cursor at the first <code>&lt;li&gt;|&lt;/li&gt;</code>.  Then after you type something, if you hit <code>&lt;tab&gt;</code> again, it will jump to the next <code>li</code>.  It is smart enough to know whether to expand or jump to the next tag.</p>

<p>So how does this functionality look like in Vim?  <!--more-->First, you must install the <a href="https://github.com/mattn/zencoding-vim">zencoding-vim</a> plugin to get this functionality (Emmet used to be named Zen Coding).  However, by default it&rsquo;s mappings are <code>&lt;C-y&gt;,</code> to expand, and <code>&lt;C-y&gt;n</code> to jump to the next tag.  There are two problems here.  First, these mappings are <strong>really</strong> awkward to type.  And secondly, there are two mappings!  You could, of course, remap it do something else, but let&rsquo;s be honest, <code>&lt;leader&gt;</code> whatever just does not compare with <code>&lt;tab&gt;</code>.</p>

<p>How can we replicate this functionality in Vim?</p>

<h1>Expression Mappings</h1>

<p>Most of the time, you will see people do mappings in Vim like <code>nnoremap j gj</code> which is a very simple and straightforward mapping.  Other times you may see something like <code>nnoremap Q :call CloseWindow()&lt;cr&gt;</code> where a key is mapped to a function.  But rarely will you see anyone use <code>&lt;expr&gt;</code> mappings.  What are these?  Long story short, you can determine what to map based on the return value of the function.  To replicate the above tab behavior, let&rsquo;s first set up a basic mapping:</p>

<p><code>vim
function! s:zen_html_tab()
  return "\&lt;c-y&gt;,"
endfunction
autocmd FileType html imap &lt;buffer&gt;&lt;expr&gt;&lt;tab&gt; &lt;sid&gt;zen_html_tab()
</code></p>

<p>There&rsquo;s a lot of things going on here, so I&rsquo;ll go over them one by one.</p>

<ul>
<li><code>s:</code> denotes that the function is scoped to the script.  You can, of course, define the function globally (must be PascalCased or script#prefixed), but I prefer not to pollute the global scope if I don&rsquo;t have to.  The return value is an escaped string which are the keys you want to map.  An additional thing to note is that you need <code>&lt;sid&gt;</code> to reference the function in the mapping.</li>
<li>The FileType autocmd is used to set up the mapping only for HTML files.</li>
<li><code>&lt;buffer&gt;</code> denotes that the mapping should only apply for the current buffer (without this when you open an HTML file it will apply the mapping globally).</li>
<li><code>&lt;expr&gt;</code> is the special sauce that lets you to execute code to determine the value of the mapping.</li>
</ul>


<p>OK, the above doesn&rsquo;t actually do anything yet.  In fact, it&rsquo;s pretty much equivalent to <code>imap &lt;tab&gt; &lt;c-y&gt;,</code>.  So let&rsquo;s add some context into it:</p>

<p>``` vim
function! s:zen_html_tab()
  let line = getline(&lsquo;.&rsquo;)
  if match(line, &lsquo;&lt;.*>&rsquo;) >= 0</p>

<pre><code>return "\&lt;c-y&gt;n"
</code></pre>

<p>  endif
  return &ldquo;&lt;c-y>,&rdquo;
endfunction
```</p>

<p>This is a simple implementation that captures the majority of use cases.  <code>getline('.')</code> gets the current line under the cursor.  <code>match()</code> is a built-in function which returns the index of the matched regular expression.  I am relying on the fact that Emmet syntax will <em>not</em> have an opening &lt;.  This makes the function very simple; if there&rsquo;s an &lt;> then jump to the next tag, otherwise, expand.</p>

<p>And that&rsquo;s all there is to it!  This function won&rsquo;t cover more &ldquo;advanced&rdquo; scenarios like nested expansions (although you could cheat by creating a newline), but otherwise it shows that expression mappings are an easy way to get more umph from your mappings.</p>

<p>For more details, contact your local Vim department by calling <code>:help map-&lt;expr&gt;</code>.</p>
]]></content>
  </entry>
  
</feed>
