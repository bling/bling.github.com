
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>CQRS: Building a “Transactional” Event Store with MongoDB - bling on software development</title>
  <meta name="author" content="Bailey Ling">

  
  <meta name="description" content="As you all already know if you’re familiar with MongoDB, is that it does not support transactions.&nbsp; The closest thing we have is atomic &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://bling.github.io//blog/2010/12/04/cqrs-building-transactional-event-store">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="bling on software development" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic,700italic|Ubuntu:300,400,500,700,300italic,400italic,500italic,700italic' rel='stylesheet' type='text/css'>


  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-38439430-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">bling on software development</a></h1>
  
    <h2>when pragmatism meets minimalism</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:bling.github.io/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">CQRS: Building a “Transactional” Event Store With MongoDB</h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-04T00:00:00+00:00" pubdate data-updated="true">Dec 4<span>th</span>, 2010</time>
        
      </p>
    
  </header>


<div class="entry-content"><div class='post'>
<p>As you all already know if you’re familiar with MongoDB, is that it does not support transactions.&nbsp; The closest thing we have is atomic modifications of a single document.</p> <p>The Event Store in a CQRS architecture has the important responsibility of detecting concurrency violations, where two different sources try to update the same version of the aggregate.&nbsp; The one that gets it late should be denied changes into the store with an exception thrown.&nbsp; This ensures the integrity of the data.</p> <p>Here is a very simple typical implementation of appending events into the event store:</p><pre style="border-bottom: #cecece 1px solid; border-left: #cecece 1px solid; padding-bottom: 5px; background-color: #fbfbfb; min-height: 40px; padding-left: 5px; width: 650px; padding-right: 5px; overflow: auto; border-top: #cecece 1px solid; border-right: #cecece 1px solid; padding-top: 5px"><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px"><span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> Append(Guid id, <span style="color: #0000ff">long</span> expectedVersion, IEnumerable&lt;IEvent&gt; events)
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">{
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; <span style="color: #0000ff">try</span>
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; {
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp;&nbsp;&nbsp; _events.Insert(events.Select(x =&gt; ...)); <span style="color: #008000">// convert to storage type</span>
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; }
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; <span style="color: #0000ff">catch</span> (...)
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; {
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; <span style="color: #0000ff">&nbsp; if</span> (E11000 duplicate key)
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; <span style="color: #0000ff">&nbsp;&nbsp;&nbsp; throw</span> <span style="color: #0000ff">new</span> ConcurrencyException(...);
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; }
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">}</pre></pre>
<p>Syntax is a mix of C#/pseudo code, but the basic concepts are the same.&nbsp; This assumes that you’ve set up an multi-index on the collection between the ID and the version.&nbsp; Thus, when you insert something that already has a matching ID/version, Mongo will tell you of a duplicate key violation, and all is good.</p>
<p>But wait!&nbsp; Operations are atomic per document!&nbsp; So what happens if you append 100 events, and it fails on the 43rd one?&nbsp; Events 1 through 42 will continue to exist in the data store, which is bad news.</p>
<p>Obviously, this solution is not going to work.&nbsp; The next step was to do something like this:</p><pre style="border-bottom: #cecece 1px solid; border-left: #cecece 1px solid; padding-bottom: 5px; background-color: #fbfbfb; min-height: 40px; padding-left: 5px; width: 650px; padding-right: 5px; overflow: auto; border-top: #cecece 1px solid; border-right: #cecece 1px solid; padding-top: 5px"><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px"><span style="color: #0000ff">catch</span> (...)
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">{
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px"><span style="color: #0000ff">&nbsp; if</span> (E11000 duplicate keys)
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; {
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px"><span style="color: #0000ff">&nbsp;&nbsp;&nbsp; foreach</span> (var e <span style="color: #0000ff">in</span> events)
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _events.Delete(<span style="color: #0000ff">new</span> { _id = e._id });
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp;</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px"><span style="color: #0000ff">&nbsp;&nbsp;&nbsp; throw</span> <span style="color: #0000ff">new</span> ConcurrencyException(...);
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">&nbsp; }
</pre><pre style="background-color: #fbfbfb; margin: 0em; width: 100%; font-family: consolas,'Courier New',courier,monospace; font-size: 12px">}</pre></pre>
<p>So, before inserting into the collection, each events gets a generated ObjectID, so that if it fails, the catch exception can simply tell the data store to delete everything.</p>
<p>At first glance this seems to fix everything, except for one glaring problem.&nbsp; What happens if you lose connection to the database before, or midway sending the deletes?&nbsp; Now you have a problem of <strong>ensuring</strong> that those deletes are guaranteed, and so then the question that arises from that is <strong>where</strong> would you store it?&nbsp; A local file?&nbsp; Another database?&nbsp; The problem is, at that moment, if another process in the system queries all events for the same aggregate it will return invalid data.</p>
<p>So, we’re back to square one.&nbsp; We need to simulate a transaction through a single insert.</p>
<p>The secret is in the schema design.&nbsp; Initially, we started out with a straight forward row-per-event schema.&nbsp; But since we’re operating with <em>documents</em>, we can model it as a <em>batch</em> of events.</p>
<p>Thus, instead of versioning every event individually, we version a batch of events.&nbsp; For example, originally we would insert 3 events, and the data saved would look like this:</p>
<blockquote>
<p>{ _id = 1, aggregate_id = 1, version = 1, event = { … } }<br>{ _id = 2, aggregate_id = 1, version = 2, event = { … } }<br>{ _id = 3, aggregate_id = 1, version = 3, event = { … } }</p></blockquote>
<p>In the new schema, it would look like this:</p>
<blockquote>
<p>{ _id = 1, aggregate_id = 1, version = 1, <strong>events</strong> = [ { … }, { … }, { … }, { … } ] }</p></blockquote>
<p>Now, a downside to this approach is you lose a bit of granularity of stored events, since you are grouping multiple events under a single version.&nbsp; However, I don’t see this as a huge loss since the main reason you want to use event sourcing in the first place is to be able to restore an aggregate to any state in its history, and we still retain that functionality.</p>
<p>In our case, this is working very well for us.&nbsp; When a command gets handled, it generates a bunch of events that get applied and then saved to MongoDB.&nbsp; I can’t think of any scenario where it’d want to replay to the middle of a half-processed command (but of course it’s possible anyways, just reply half of a batch of events).&nbsp; But that’s just asking for trouble.&nbsp; It’s most likely easier to just the re-process the command.</p>
<p>Now, you may be asking why go through the trouble of batching events when you can just store one document per aggregate, and then put all events in one document?&nbsp; Yes, that would solve the problem very effectively…until you hit the 4MB per document limit ;-)</p>  </div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Bailey Ling</div>
<div class='content'>
It wouldn&#39;t be any different from processing a new command.  You will need to load all snapshots/events to get the aggregate root to the latest version.  Events should typically be &quot;fire and forget&quot;.  If you require them to be guaranteed delivery it&#39;s better to restructure them as commands.</div>
</div>
<div class='comment'>
<div class='author'>bodrin</div>
<div class='content'>
Nice, thanks for answering :)<br />I should definitely take a closer look at the MongoDB! Sounds very interesting :)<br /><br />On the other hand I&#39;m still wondering if there is a general approach for this situation - you have done a state transition into the KV/doc DB and you have some events there. Then your system goes down just before it publishes these events on to the wire (some external messaging system). Then when you start again is there an efficient way/query to be done against the KV/doc DB so that you get all the events that haven&#39;t been dispatched yet?</div>
</div>
<div class='comment'>
<div class='author'>Bailey Ling</div>
<div class='content'>
Well, the easiest way is to cheat and use Mongo as your messaging bus ;-)  There&#39;s a bunch of examples on the web.  Basically, you create a direct connection against the database and read the oplog.  This is the mechanism that Mongo uses to do replication, so you get near real-time performance.  Since it&#39;s only one system to manage, rather than two in concert, it&#39;s a bit easier to maintain.  You&#39;ll get the same guarantees as any other write to a Mongo node.<br /><br />If you must go to another messaging system it&#39;ll depend on the guarantees of that implementation.  It&#39;s not the end of the world to tell the user to &quot;try again later&quot;, assuming that&#39;s acceptable for the 0.01% of the time.<br /><br />Also, if the messaging system is down, you can still read from the event store to get the latest information (and is required for stale nodes joining the system).</div>
</div>
<div class='comment'>
<div class='author'>bodrin</div>
<div class='content'>
Hi, I want to ask how do you dispatch the events. I guess the flow is somthing like this:<br /><br />1. receive a command<br />2. load the related AR and process the command which produces some events - a batch<br />3. store the event batch in MongoDB, e.g. at <br />{ &quot;_id&quot;: { &quot;aggregate&quot;: 1234, &quot;version&quot;: 65 } }<br />4. dispatch the events to some messaging system<br />5. mark the { &quot;_id&quot;: { &quot;aggregate&quot;: 1234, &quot;version&quot;: 65 } } as dispatched<br /><br />So if this is similar to what you are doing I&#39;m wondering what if the system goes down just after step 3. ?<br />The events are not dispatched, but how do you find that after restart? Is there an efficient way with MongoDb and/or with other documen / KV stores?</div>
</div>
<div class='comment'>
<div class='author'>bling</div>
<div class='content'>
Thanks for the comments!<br /><br />You are absolutely right in all of your points.<br /><br />Actually, each individual event in my system is meaningless unless it is part of a batch.  The batch is the only thing that is versioned, and the batch version is required to save or get events from the store.<br /><br />As for duplicate handling, since I wrote the post I implemented _id as a complex object like this:<br /><br />{ &quot;_id&quot;: { &quot;aggregate&quot;: 1234, &quot;version&quot;: 65 } }<br /><br />_id is always indexed, and unique.  If version 66 already exists, the 2nd command handler will simply fail, and the event store will continue to have good, consistent data.</div>
</div>
<div class='comment'>
<div class='author'>Jonathan Oliver</div>
<div class='content'>
Awesome post.  <br /><br />When I started writing version 2.0 of my EventStore library, I wanted to ensure that NoSQL databases such as MongoDB could be handled.  Pushing everything up as a single batch is critical.<br /><br />Here is the implementation for Mongo:<br />https://github.com/joliver/EventStore/tree/master/src/proj/EventStore.Persistence.MongoPersistence<br /><br />Here is the design guide:<br />http://jonathan-oliver.blogspot.com/2010/12/cqrs-eventstore-v2-architectural.html<br /><br />There are three quick things I wanted to mention regarding your implementation.  First, because you&#39;re now pushing things up as a batch, you can no longer use the event version as an optimistic control technique.  Instead, you&#39;ll want to number each batch that you push using a sequential, incrementing value.<br /><br />Lastly, if you only push the event information, you may lose some context because there is oftentimes metadata associated with all of the events that you&#39;ll want to store.<br /><br />You&#39;ll also want to consider what happens when a message is processed more than once which causes a batch to be written.  NoSQL doesn&#39;t provide any guarantees related to de-duplication so you&#39;ll need to handle that in your application code/event store code.</div>
</div>
</div>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Bailey Ling</span></span>

      








  


<time datetime="2010-12-04T00:00:00+00:00" pubdate data-updated="true">Dec 4<span>th</span>, 2010</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/coding/'>coding</a>, <a class='category' href='/blog/categories/cqrs/'>cqrs</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://bling.github.io//blog/2010/12/04/cqrs-building-transactional-event-store/" data-via="blingcoder" data-counturl="http://bling.github.io//blog/2010/12/04/cqrs-building-transactional-event-store/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2010/11/23/cqrs-auto-register-event-handlers/" title="Previous Post: CQRS: Auto register event handlers">&laquo; CQRS: Auto register event handlers</a>
      
      
        <a class="basic-alignment right" href="/blog/2010/12/05/working-in-git-to-working-in-mercurial/" title="Next Post: Working in Git to Working in Mercurial">Working in Git to Working in Mercurial &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/09/vim-in-emacs-bootstrap/">Vim in Emacs Bootstrap</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/16/modularizing-vimscript/">Modularizing VimScript</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/30/1000-stars-in-1-month/">1000 stars in 1 month</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/21/smart-tab-expansions-in-vim-with-expression-mappings/">Smart tab expansions in Vim with expression mappings</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/15/flight-of-an-open-source-project/">The flight of an open-source project</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/">Unite.vim, The plugin you didn't know you need</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/19/on-typescript/">On TypeScript</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/13/dot-net-slash-wpf-to-html-slash-css-slash-javscript/">.NET/WPF to HTML/CSS/Javscript</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/bling">@bling</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'bling',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Bailey Ling -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
